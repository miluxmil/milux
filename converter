#!/data/data/com.termux/files/usr/bin/bash

#update 2024
#Functions
#imagemagick

C='\033[1;36m'
G='\033[1;32m'
R='\033[1;31m'
Y='\033[1;33m'
B='\033[1;34m'
P='\033[1;35m'
RE='\033[0m'

YEAR=2025
#trap "ctl_c" SIGINT
message="CONVERTER | Iniciando"
cols=$(stty size | awk '{print $2}')
msg_len=${#message}
center=$(( (cols - msg_len) / 2 ))
printf "\n%.0s" {1..5}
tput cuf $center
FORMATOS=$(ffmpeg -formats 2>/dev/null | grep E | awk '{print $2}';identify -list format | awk '{print $1}' | grep -v '^$' | sed 's/\*//g')
PROFILE_SELECTED=0


command -v ffmpeg > /dev/null 2>&1 || { echo >&2 "Al parecer no tienes FFMPEG, espera";sleep 2;apt install -y ffmpeg;bash $0 ; }
command -v mogrify > /dev/null 2>&1 || { echo >&2 "Al parecer no tienes imagemagick, espera" ; sleep 2 ; apt install -y imagemagick ; bash $0 ; }

function _Logo {
        clear
        echo -e "$P"
echo -e "
      \_/
     (* *)
    __)#(__
   ( )...( )(_)  $G C O N V E R T E R$P
   || |_| ||//     $G      By$P
>==() | | ()/      $G </[M]iLu{×}_> | DNP | $YEAR $P
    _(___)_
   [-]   [-]  $RE      Music - Video - Images
   "   

}

function ctl_c(){
_Logo
echo -e "$G Saliendo de Converter...";sleep 0.5
_Logo
echo -e "OK, BYE BYE!";exit

}


spin () {
local pid=$!
local delay=0.25
local spinner=( '█■■■■■' '■█■■■■' '■■█■■■' '■■■█■■' '■■■■█■' '■■■■■█' )

while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do

	for i in "${spinner[@]}"
	do
		tput civis
		echo -ne "\033[1;33m\r Convirtiendo, ten paciencia......\e[33m[\033[32m$i\033[33m]\033[0m   ";
		sleep $delay
		printf "\b\b\b\b\b\b\b\b";
	done
done
printf "   \b\b\b\b\b"
tput cnorm
_Logo
printf "\033[1;33m [\e[1;36m Conversion OK..\033[1;33m ]\e\n";sleep 1;
echo "";
}

function _Menu() {
	CCV=$(cat ~/.milux/cav.mlx 2>/dev/null || echo "V-2.0")
	_Logo
echo -e $G"Elije una opcion

	[$RE 1$G ]$Y Audio $G
	[$RE 2$G ]$Y Imagen $G
	[$RE 3$G ]$Y Video $G
	[$RE 4$G ]$Y Extraer audio $G
	[$RE 5$G ]$Y Perfiles preconfigurados $G
	[$RE 6$G ]$Y Acerca de.. $G
	[$RE 9$G ]$Y Actualizar..$G
	[$RE 0$G ]$Y Salir $G
	"
	while read -p "-Milux- Convert $CCV >> " OPT && [ -z "$OPT" ];do
	echo -e $R"[!]$Y Debes ingresar una opcion valida    $RE";sleep 1;_Menu
done
	case $OPT in
		1)
			MODE="- Audio -";FR1=mp3;FR2=wma;FR3=ogg
			_Main
			;;
		2)
			MODE="- Imagen -";FR1=jpeg;FR2=png;FR3=jpg
			_Main
			;;
		3)
			MODE="- Video -";FR1=avi;FR2=wmv;FR3=mp4
			_Main
			;;
		4)
			MODE="- Extraer Audio -";FR1=mp3;FR2=wav;FR3=ogg
			_Main
			;;
		5)
			_Profiles
			;;
		6)
        		_About
			;;
		9)
			_Update
			;;
		0)
			ctl_c
			;;
		*)
			echo -e $R"Opción inválida"; sleep 1; _Menu
			;;
	esac

}


function _Main() { 
_Logo
echo -e $G"Escribe la ruta donde se encuentra\ntu archivo a convertir$RE Ejem.:$R /sdcard/MiFolder$RE"

while read -p "$MODE >> " RUTA && [ -z "$RUTA" ];do
	echo -e $R"[!]$Y Debes ingresar una ruta valida
$RE"
done

if [ "$RUTA" = "mi" ];then
	RUTA="/sdcard/youtube"
fi

ls "$RUTA" > /dev/null 2>&1;C1=$?

if [ "$C1" = "0" ];then
	_Continue
else
	echo -e $R"[!]$Y Ruta no existe, verificala$RE";sleep 3
	bash "$0"
fi
}

function _Continue() {
    _Logo
    echo -e "$G Estas ubicado en:$RE $RUTA"
    # Listar archivos numerados
    local count=1
    FILES=()
    for file in "$RUTA"/*; do
        if [ -f "$file" ]; then
            echo -e "${R}[${RE} $count ${R}]${G} $(basename "$file")${RE}"
            FILES+=("$(basename "$file")")
            ((count++))
        fi
    done

    echo -e $G"
$R[$Y r$R ]$G REFRESH   $R[$Y d$R ]$G DELETE
$R[$Y p$R ]$G NEW PATH  $R[$Y n$R ]$G NEW CONVERSION
$R[$Y c$R ]$G COPY      $R[$Y m$R ]$G MOVE  
"
    while read -p "Selecciona una o varias opciones 
Separadas por un espacio >> " -a OPTION && [ -z "${OPTION[*]}" ]; do
        echo -e $R"[!]$Y Debes ingresar una opcion$RE"
    done

    # Manejar comandos especiales
    if [ ${#OPTION[@]} -eq 1 ]; then
        case "${OPTION[0]}" in
            r|R)
                _Continue
                return
                ;;
            d|D)
                CM="rm -rf"
                _CopyMoveDel "$RUTA"
                return
                ;;
            p|P)
                _Main
                return
                ;;
            n|N)
                _Menu
                return
                ;;
            c|C)
                CM="cp -r"
                _CopyMoveDel "$RUTA"
                return
                ;;
            m|M)
                CM="mv"
                _CopyMoveDel "$RUTA"
                return
                ;;
        esac
    fi

    # Procesar selección de archivos
    _Check
}

function _CopyMoveDel(){
	local RUTA=$1
	_Logo
    local count=1
    FILES=()
    for file in "$RUTA"/*; do
        if [ -f "$file" ]; then
            echo -e "${R}[${RE} $count ${R}]${G} $(basename "$file")${RE}"
            FILES+=("$(basename "$file")")
            ((count++))
        fi
    done
	 echo -e "$G"
	 
	 if [ "$CM" = "cp -r" ];then
		 CME="copiar"
	elif [ "$CM" = "mv" ];then
		CME="mover"
	elif [ "$CM" = "rm -rf" ];then
		CME="eliminar"
	 fi

	read -p "Selecciona archivos a $CME (números), separados por espacios. 
	>> " -a OPTIONS
	if [ "$CM" = "cp -r" ] || [ "$CM" = "mv" ];then
        read -p "Escribe la ruta destino >> " COPY
        mkdir -p "$COPY" 2>/dev/null
	fi

    local selected_files=()
    for INDEX in "${OPTIONS[@]}"; do
        if [ "$INDEX" -le "${#FILES[@]}" ] && [ "$INDEX" -gt 0 ]; then
            selected_files+=("${FILES[$((INDEX-1))]}")
        fi
    done

    for FILE in "${selected_files[@]}"; do
        echo "$CME $FILE..."
        if [ "$CM" = "rm -rf" ]; then
            $CM "$RUTA/$FILE"
        else
            $CM "$RUTA/$FILE" "$COPY"
        fi
    done
    _Continue
}

function _Music() {
    for FILE in "${FILES[@]}"; do
        _Logo
        echo -e $G"Archivo:$Y "$FILE"" 
        
        # Preguntar por metadatos
        read -p "¿Agregar metadatos? (s/n): " ADD_METADATA
        if [[ "$ADD_METADATA" =~ [sS] ]]; then
            read -p "Título: " TITLE
            read -p "Artista: " ARTIST
            read -p "Álbum: " ALBUM
            
            ffmpeg -i "$RUTA/$FILE" \
                -metadata title="$TITLE" \
                -metadata artist="$ARTIST" \
                -metadata album="$ALBUM" \
                -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
        else
            ffmpeg -i "$RUTA/$FILE" -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
        fi
    done
    _Part2    
}

function _Image(){
    for FILE in "${FILES[@]}"; do
        _Logo
        echo -e $G"Convirtiendo: $Y $FILE"
        mogrify -format $EXIT -path "$RUTA" "$RUTA/$FILE" > /dev/null 2>&1 & spin
    done
    _Part2
}

function _Video(){
    for FILE in "${FILES[@]}"; do
        _Logo
        echo -e $G"Convirtiendo: $Y $FILE"
        if [ "$PROFILE_SELECTED" -eq 1 ]; then
            ffmpeg -i "$RUTA/$FILE" -c:v $VIDEO_CODEC -c:a $AUDIO_CODEC \
                -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
        else
            ffmpeg -i "$RUTA/$FILE" -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
        fi
    done
    _Part2
} 

function _ExtractAudio() {
    AUDIO_QUALITY="192k"
    for FILE in "${FILES[@]}"; do
        _Logo
        echo -e $G"Extrayendo audio de:$Y "$FILE"" 
        ffmpeg -i "$RUTA/$FILE" -vn -ab $AUDIO_QUALITY -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
    done
    _Part2
}

function _Part2(){
_Logo
echo -e $G"¿Que hago con archivos originales?

[$RE 1$G ]$Y Conservar$G
[$RE 2$G ]$Y Eliminar$G
[$RE 3$G ]$Y Eliminar antiguos y Mover nuevos$G
"
while read -p "$MODE >> " WDO && [ -z "$WDO" ];do
	echo -e $R"[!]$Y Debes ingresar una opcion valida    $RE"
done

if [ "$WDO" = "1" ];then
	_OK
	_Continue

elif [ "$WDO" = "2" ];then
	for FILE in "${FILES[@]}"; do
		rm -f "$RUTA/$FILE"
	done
	_OK
	_Continue

elif [ "$WDO" = "3" ];then
	while read -p "Ingresa la ruta destino >> " DEST && [ -z "$DEST" ];do
		echo -e $R"[!]$Y Debes ingresar una ruta valida    $RE"
	done

	if [ "$DEST" = "sp" ];then
		DEST="/sdcard/youtube/spotify"
	fi

	mkdir -p "$DEST" > /dev/null 2>&1
	if [ $? -eq 0 ]; then
        for FILE in "${FILES[@]}"; do
            rm -f "$RUTA/$FILE"
            echo -e $RE"Moviendo:$Y ${FILE%.*}.$EXIT";sleep 0.2
            mv -f "$RUTA/${FILE%.*}".$EXIT "$DEST" 2>/dev/null
        done
        _Continue
    else
        _Logo
        echo -e $R"Error al crear directorio destino"
        sleep 2
        _Part2
    fi
else
	echo -e $R"[!]$Y Opcion invalida$RE";sleep 3
    _Part2
fi
}

function _Check() {
    FILES_TO_PROCESS=()
    for INDEX in "${OPTION[@]}"; do
        if [ "$INDEX" -le "${#FILES[@]}" ] && [ "$INDEX" -gt 0 ]; then
            FILE_NAME="${FILES[$((INDEX-1))]}"
            FILES_TO_PROCESS+=("$FILE_NAME")
            FORMATO_ARCHIVO="${FILE_NAME##*.}"
            
            if ! echo "$FORMATOS" | grep -q "^$FORMATO_ARCHIVO$"; then
                _Logo
                echo -e $R"Archivo incompatible:$Y $FILE_NAME"
                sleep 3
                _Continue
                return
            fi
        fi
    done

    FILES=("${FILES_TO_PROCESS[@]}")

    _Logo
    echo -e "$Y Ingresa el formato de salida,$RE Ejemplo:$C $FR1, $FR2, $FR3 etc.$RE"
    read -p " -Milux- convert >> " EXIT

    while [ -z "$EXIT" ]; do
        echo -e $R"[X]$Y No escribiste nada o Formato incompatible $RE"
        read -p " -Milux- convert >> " EXIT
    done

    _Logo
    echo -e $G"La informacion, es correcta? s/n
$G Archivo(s):$RE"

    for FILE in "${FILES[@]}"; do
        echo -e "$FILE"
    done

    echo -e $G"Formato:$Y $EXIT $RE"
    read -p " S o N >> " SINO

      if [ "$SINO" = "s" ] || [ "$SINO" = "S" ]; then
        # Preguntar si desea editar
        read -p "¿Deseas editar el archivo antes de convertir? (s/n) " EDITAR
        if [[ "$EDITAR" =~ [sS] ]]; then
            for FILE in "${FILES[@]}"; do
                _Editor
            done
    	fi

    case "$MODE" in
        "- Audio -") _Music ;;
        "- Imagen -") _Image ;;
        "- Video -") _Video ;;
        "- Extraer Audio -") _ExtractAudio ;;
        "- Perfil preconfigurado Audio Whatsapp-"|"- Perfil preconfigurado Audio Spotify-"|"- Perfil preconfigurado Instagram -")
            _ProfilesConversion
            ;;
    esac
else
	_Continue
	return
      fi
}

function _ProfilesConversion() {
    case "$MODE" in
        "- Perfil preconfigurado Audio Whatsapp-")
            for FILE in "${FILES[@]}"; do
                ffmpeg -i "$RUTA/$FILE" -c:a libopus -b:a $AUDIO_QUALITY \
                    -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
            done
            ;;
        "- Perfil preconfigurado Audio Spotify-")
            for FILE in "${FILES[@]}"; do
                ffmpeg -i "$RUTA/$FILE" \
                    -metadata title="$TITLE" \
                    -metadata artist="$ARTIST" \
                    -metadata album="$ALBUM" \
                    -b:a $AUDIO_QUALITY \
                    -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
            done
            ;;
        "- Perfil preconfigurado Instagram -")
            for FILE in "${FILES[@]}"; do
                ffmpeg -i "$RUTA/$FILE" \
                    -c:v $VIDEO_CODEC \
                    -c:a $AUDIO_CODEC \
                    -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
            done
            ;;
    esac
    _Part2
}

function _Profiles() {
    _Logo
    echo -e $G"Selecciona un perfil:"
    echo -e "[$RE 1$G ]$Y WhatsApp (audio: opus)$G"
    echo -e "[$RE 2$G ]$Y Spotify (audio: mp3 256k con metadatos)$G"
    echo -e "[$RE 3$G ]$Y Instagram (video: mp4 H.264)$G"
    echo -e "[$RE 4$G ]$Y Volver al menú principal$RE"
    
    while read -p " >> " PROFILE_OPT && [ -z "$PROFILE_OPT" ]; do
        echo -e $R"Selecciona una opción válida"
    done
    
    case $PROFILE_OPT in
        1)
            _WhatsappProfile
            ;;
        2)
            _SpotifyProfile
            ;;
        3)
            _InstagramProfile
            ;;
        4)
            _Menu
            ;;
        *)
            echo -e $R"Opción inválida, intenta de nuevo"
            sleep 1
            _Profiles
            ;;
    esac
}

function _WhatsappProfile() {
    MODE="- Perfil Whatsapp -"
    EXIT="opus"
    AUDIO_QUALITY="64k"
    _ProfileMain
}

function _SpotifyProfile() {
    MODE="- Perfil Spotify -"
    EXIT="mp3"
    AUDIO_QUALITY="256k"
    _ProfileMain
}

function _InstagramProfile() {
    MODE="- Perfil Instagram -"
    EXIT="mp4"
    VIDEO_CODEC="libx264"
    AUDIO_CODEC="aac"
    _ProfileMain
}

function _ProfileMain() { 
    _Logo
    echo -e $G"Escribe la ruta donde se encuentran los archivos\n$RE Ejemplo:$R /sdcard/MisAudios$RE"

    while read -p "$MODE >> " RUTA && [ -z "$RUTA" ]; do
        echo -e $R"[!]$Y Debes ingresar una ruta válida$RE"
    done

    if [ "$RUTA" = "mi" ]; then
        RUTA="/sdcard/youtube"
    fi

    ls "$RUTA" > /dev/null 2>&1
    if [ $? -ne 0 ]; then
        echo -e $R"[!]$Y Ruta no existe, verifícala$RE"; sleep 3
        _ProfileMain
    else
        _ProfileContinue
    fi
}

function _ProfileContinue() {
    _Logo
    echo -e "$G Estás ubicado en:$RE $RUTA"
    echo -e "$G Perfil seleccionado:$Y $MODE$RE"
    echo -e "$G Formato de salida:$Y $EXIT$RE"
    
    # Listar archivos
    local count=1
    FILES=()
    for file in "$RUTA"/*; do
        if [ -f "$file" ]; then
            echo -e "${R}[${RE} $count ${R}]${G} $(basename "$file")${RE}"
            FILES+=("$(basename "$file")")
            ((count++))
        fi
    done

    echo -e $G"
$R[$Y a$R ]$G SELECCIONAR TODOS  $R[$Y r$R ]$G REFRESCAR
$R[$Y p$R ]$G NUEVA RUTA        $R[$Y m$R ]$G VOLVER AL MENÚ
"
    read -p "Selecciona archivos (números) separados por espacios >> " -a OPTIONS
    
    if [[ "${OPTIONS[*]}" == *a* ]] || [[ "${OPTIONS[*]}" == *A* ]]; then
        # Seleccionar todos los archivos
        SELECTED_FILES=("${FILES[@]}")
    elif [[ "${OPTIONS[*]}" == *r* ]] || [[ "${OPTIONS[*]}" == *R* ]]; then
        _ProfileContinue
        return
    elif [[ "${OPTIONS[*]}" == *p* ]] || [[ "${OPTIONS[*]}" == *P* ]]; then
        _ProfileMain
        return
    elif [[ "${OPTIONS[*]}" == *m* ]] || [[ "${OPTIONS[*]}" == *M* ]]; then
        _Menu
        return
    else
        # Procesar selección manual
        SELECTED_FILES=()
        for INDEX in "${OPTIONS[@]}"; do
            if [[ $INDEX =~ ^[0-9]+$ ]] && [ "$INDEX" -le "${#FILES[@]}" ] && [ "$INDEX" -gt 0 ]; then
                SELECTED_FILES+=("${FILES[$((INDEX-1))]}")
            fi
        done
    fi

    if [ ${#SELECTED_FILES[@]} -eq 0 ]; then
        echo -e $R"[!] No seleccionaste ningún archivo$RE"
        sleep 1
        _ProfileContinue
        return
    fi

    FILES=("${SELECTED_FILES[@]}")
    
    # Confirmar conversión
    _Logo
    echo -e "$G Archivos seleccionados:$Y"
    for FILE in "${FILES[@]}"; do
        echo "- $FILE"
    done
    
    echo -e $G"
Perfil: $Y$MODE
Formato: $Y$EXIT
$R[$Y s$R ]$G INICIAR CONVERSIÓN
$R[$Y n$R ]$G CANCELAR Y VOLVER
"
    read -p " >> " CONFIRM
    
    if [[ "$CONFIRM" =~ [sS] ]]; then
        _ProcessProfileConversion
    else
        _ProfileContinue
    fi
}

function _ProcessProfileConversion() {
    case "$MODE" in
        "- Perfil Whatsapp -")
            for FILE in "${FILES[@]}"; do
                _Logo
                echo -e $G"Convirtiendo a WhatsApp Audio:$Y $FILE"
                ffmpeg -i "$RUTA/$FILE" -c:a libopus -b:a $AUDIO_QUALITY \
                    -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
            done
            ;;
            
        "- Perfil Spotify -")
            for FILE in "${FILES[@]}"; do
                _Logo
                echo -e $G"Convirtiendo a Spotify:$Y $FILE"
                read -p "Título: " TITLE
                read -p "Artista: " ARTIST
                read -p "Álbum: " ALBUM
                
                ffmpeg -i "$RUTA/$FILE" \
                    -metadata title="$TITLE" \
                    -metadata artist="$ARTIST" \
                    -metadata album="$ALBUM" \
                    -b:a $AUDIO_QUALITY \
                    -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
            done
            ;;
            
        "- Perfil Instagram -")
            for FILE in "${FILES[@]}"; do
                _Logo
                echo -e $G"Convirtiendo a Instagram:$Y $FILE"
                ffmpeg -i "$RUTA/$FILE" \
                    -c:v $VIDEO_CODEC \
                    -c:a $AUDIO_CODEC \
                    -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
            done
            ;;
    esac
    
    _ProfilePart2
}

function _ProfilePart2() {
    _Logo
    echo -e $G"Conversión completada!$RE"
    echo -e "$Y Archivos convertidos:$G"
    for FILE in "${FILES[@]}"; do
        echo "- ${FILE%.*}.$EXIT"
    done
    
    echo -e $G"
¿Qué deseas hacer con los originales?
$R[$Y 1$R ]$G CONSERVAR ORIGINALES
$R[$Y 2$R ]$G ELIMINAR ORIGINALES
$R[$Y 3$R ]$G MOVER A CARPETA DIFERENTE
$R[$Y 4$R ]$G VOLVER AL MENÚ PRINCIPAL
"
    read -p " >> " OPT
    
    case $OPT in
        1)
            echo -e $G"Originales conservados en:$Y $RUTA$RE"
            sleep 2
            _Menu
            ;;
        2)
            for FILE in "${FILES[@]}"; do
                rm -f "$RUTA/$FILE"
            done
            echo -e $G"Originales eliminados$RE"
            sleep 2
            _Menu
            ;;
        3)
            read -p "Ruta destino para originales: " DEST
            mkdir -p "$DEST" 2>/dev/null
            if [ $? -eq 0 ]; then
                for FILE in "${FILES[@]}"; do
                    mv -f "$RUTA/$FILE" "$DEST/"
                done
                echo -e $G"Originales movidos a:$Y $DEST$RE"
            else
                echo -e $R"Error al crear directorio destino"
            fi
            sleep 2
            _Menu
            ;;
        *)
            _Menu
            ;;
    esac
}

function _OK() {
	_Logo
	echo -e "$Y Convertido correctamente!\n Guardado como...$G"
	for FILE in "${FILES[@]}"; do
		echo -e "${FILE%.*}.$EXIT"
	done
    echo -e $Y"En:$G $RUTA $RE"
    read -n 1 -p "ENTER To continue.."
    _Continue
}

function _Editor() {
    _Logo
    echo -e "$G EDITOR MULTIMEDIA - $FILE$RE"
    echo -e "$Y Selecciona una operación:$G"
    
    # Determinar tipo de archivo
    if file "$RUTA/$FILE" | grep -q "Audio"; then
        tipo="audio"
    elif file "$RUTA/$FILE" | grep -q "Video"; then
        tipo="video"
    else
        tipo="Imagen"
    fi

    # Menú según tipo
    case $tipo in
        "audio")
            echo -e "  $R[$Y 1$R ]$G Recortar audio"
            echo -e "  $R[$Y 2$R ]$G Normalizar volumen"
            echo -e "  $R[$Y 3$R ]$G Aplicar fade in/out"
            ;;
        "video")
            echo -e "  $R[$Y 1$R ]$G Recortar video"
            echo -e "  $R[$Y 2$R ]$G Rotar video"
            echo -e "  $R[$Y 3$R ]$G Redimensionar video"
            echo -e "  $R[$Y 4$R ]$G Extraer audio"
            ;;
        "imagen")
            echo -e "  $R[$Y 1$R ]$G Redimensionar imagen"
            echo -e "  $R[$Y 2$R ]$G Rotar imagen"
            echo -e "  $R[$Y 3$R ]$G Ajustar calidad"
            ;;
    esac
    
    echo -e "  0) Continuar sin editar"
    read -p " >> " EDIT_OPT

    case $EDIT_OPT in
        1)
            if [ "$tipo" = "audio" ] || [ "$tipo" = "video" ]; then
                _Recortar
            elif [ "$tipo" = "imagen" ]; then
                _RedimensionarImagen
            fi
            ;;
        2)
            if [ "$tipo" = "audio" ]; then
                _NormalizarAudio
            elif [ "$tipo" = "video" ]; then
                _RotarVideo
            elif [ "$tipo" = "imagen" ]; then
                _RotarImagen
            fi
            ;;
        3)
            if [ "$tipo" = "audio" ]; then
                _FadeAudio
            elif [ "$tipo" = "video" ]; then
                _RedimensionarVideo
            elif [ "$tipo" = "imagen" ]; then
                _CalidadImagen
            fi
            ;;
        4)
            if [ "$tipo" = "video" ]; then
                _ExtraerAudioVideo
            fi
            ;;
        0)
            return
            ;;
        *)
            echo -e $R"Opción inválida$RE"
            sleep 1
            _Editor
            ;;
    esac
}

function _Recortar() {
    _Logo
    echo -e "$G RECORTAR $FILE$RE"
    
    # Obtener duración del archivo
    duracion=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$RUTA/$FILE")
    minutos=$(printf "%02d" $(( ${duracion%.*} / 60 )))
    segundos=$(printf "%02d" $(( ${duracion%.*} % 60 )))
    
    echo -e "$Y Duración total: $minutos:$segundos$RE"
    echo -e "$G Ingresa los tiempos en formato MM:SS$RE"
    
    read -p "Inicio (ej: 00:25): " inicio
    read -p "Fin (ej: 02:30): " fin
    
    # Convertir a segundos
    min_ini=${inicio%:*}; seg_ini=${inicio#*:}
    min_fin=${fin%:*}; seg_fin=${fin#*:}
    start=$((min_ini * 60 + seg_ini))
    end=$((min_fin * 60 + seg_fin))
    
    if [ $end -le $start ]; then
        echo -e $R"Tiempo final debe ser mayor que inicial$RE"
        sleep 2
        _Recortar
        return
    fi
    
    # Crear archivo temporal
    tempfile="${FILE%.*}_recortado.${FILE##*.}"
    
    if [ "$tipo" = "audio" ]; then
        ffmpeg -i "$RUTA/$FILE" -ss $start -to $end -c copy "$RUTA/$tempfile" > /dev/null 2>&1
    else
        ffmpeg -i "$RUTA/$FILE" -ss $start -to $end -c:v copy -c:a copy "$RUTA/$tempfile" > /dev/null 2>&1
    fi
    
    if [ $? -eq 0 ]; then
        mv "$RUTA/$tempfile" "$RUTA/$FILE"
        echo -e "$G¡Recorte exitoso!$RE"
        sleep 1
    else
        echo -e $R"Error al recortar$RE"
        rm -f "$RUTA/$tempfile" 2>/dev/null
        sleep 2
    fi
}

function _NormalizarAudio() {
    _Logo
    echo -e "$G NORMALIZAR VOLUMEN - $FILE$RE"
    echo -e "$Y Ajustando volumen a nivel óptimo..."
    
    tempfile="${FILE%.*}_normalizado.${FILE##*.}"
    
    ffmpeg -i "$RUTA/$FILE" -af loudnorm=I=-16:LRA=11:TP=-1.5 "$RUTA/$tempfile" > /dev/null 2>&1
    
    if [ $? -eq 0 ]; then
        mv "$RUTA/$tempfile" "$RUTA/$FILE"
        echo -e "$G¡Audio normalizado!$RE"
        sleep 1
    else
        echo -e $R"Error al normalizar$RE"
        rm -f "$RUTA/$tempfile" 2>/dev/null
        sleep 2
    fi
}

function _RotarVideo() {
    _Logo
    echo -e "$G ROTAR VIDEO - $FILE$RE"
    echo -e "$Y Selecciona la rotación:$G"
    echo -e "  $R[$Y 1$R ]$G 90° sentido horario"
    echo -e "  $R[$Y 2$R ]$G 90° sentido antihorario"
    echo -e "  $R[$Y 3$R ]$G 180° (voltear)"
    read -p " >> " ROT_OPT

    case $ROT_OPT in
        1) filter="transpose=1" ;;
        2) filter="transpose=2" ;;
        3) filter="transpose=2,transpose=2" ;;
        *) echo -e $R"Opción inválida$RE"; sleep 1; return ;;
    esac

    tempfile="${FILE%.*}_rotado.${FILE##*.}"
    
    ffmpeg -i "$RUTA/$FILE" -vf "$filter" -c:a copy "$RUTA/$tempfile" > /dev/null 2>&1
    
    if [ $? -eq 0 ]; then
        mv "$RUTA/$tempfile" "$RUTA/$FILE"
        echo -e "$G¡Video rotado!$RE"
        sleep 1
    else
        echo -e $R"Error al rotar$RE"
        rm -f "$RUTA/$tempfile" 2>/dev/null
        sleep 2
    fi
}

function _RedimensionarVideo() {
    _Logo
    echo -e "$G REDIMENSIONAR VIDEO - $FILE$RE"
    
    # Obtener resolución original
    resolucion=$(ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 "$RUTA/$FILE")
    echo -e "$Y Resolución actual: $resolucion$RE"
    
    echo -e "$G Ingresa nueva resolución (ej: 1280x720):$RE"
    read -p " >> " nueva_res
    
    if ! echo "$nueva_res" | grep -Eq "^[0-9]+x[0-9]+$"; then
        echo -e $R"Formato inválido. Usa ANCHOxALTO$RE"
        sleep 2
        _RedimensionarVideo
        return
    fi
    
    tempfile="${FILE%.*}_resized.${FILE##*.}"
    
    ffmpeg -i "$RUTA/$FILE" -vf "scale=$nueva_res" -c:a copy "$RUTA/$tempfile" > /dev/null 2>&1
    
    if [ $? -eq 0 ]; then
        mv "$RUTA/$tempfile" "$RUTA/$FILE"
        echo -e "$G¡Video redimensionado!$RE"
        sleep 1
    else
        echo -e $R"Error al redimensionar$RE"
        rm -f "$RUTA/$tempfile" 2>/dev/null
        sleep 2
    fi
}

function _RedimensionarImagen() {
    _Logo
    echo -e "$G REDIMENSIONAR IMAGEN - $FILE$RE"
    
    # Obtener resolución original
    resolucion=$(identify -format "%wx%h" "$RUTA/$FILE")
    echo -e "$Y Resolución actual: $resolucion$RE"
    
    echo -e "$G Ingresa nueva resolución (ej: 800x600) o porcentaje (ej: 50%):$RE"
    read -p " >> " nueva_res
    
    tempfile="${FILE%.*}_resized.${FILE##*.}"
    
    if mogrify -path "$RUTA" -resize "$nueva_res" -write "$RUTA/$tempfile" "$RUTA/$FILE"; then
        mv "$RUTA/$tempfile" "$RUTA/$FILE"
        echo -e "$G¡Imagen redimensionada!$RE"
        sleep 1
    else
        echo -e $R"Error al redimensionar$RE"
        rm -f "$RUTA/$tempfile" 2>/dev/null
        sleep 2
    fi
}

function _RotarImagen() {
    _Logo
    echo -e "$G ROTAR IMAGEN - $FILE$RE"
    echo -e "$Y Selecciona la rotación:$G"
    echo -e "  $R[$Y 1$R ]$G 90° derecha"
    echo -e "  $R[$Y 2$R ]$G 90° izquierda"
    echo -e "  $R[$Y 3$R ]$G 180°"
    echo -e "  $R[$Y 4$R ]$G Voltear horizontalmente"
    echo -e "  $R[$Y 5$R ]$G Voltear verticalmente"
    read -p " >> " ROT_OPT

    case $ROT_OPT in
        1) rotacion="-rotate 90" ;;
        2) rotacion="-rotate -90" ;;
        3) rotacion="-rotate 180" ;;
        4) rotacion="-flop" ;;
        5) rotacion="-flip" ;;
        *) echo -e $R"Opción inválida$RE"; sleep 1; return ;;
    esac

    tempfile="${FILE%.*}_rotada.${FILE##*.}"
    
    if convert "$RUTA/$FILE" $rotacion "$RUTA/$tempfile"; then
        mv "$RUTA/$tempfile" "$RUTA/$FILE"
        echo -e "$G¡Imagen rotada!$RE"
        sleep 1
    else
        echo -e $R"Error al rotar$RE"
        rm -f "$RUTA/$tempfile" 2>/dev/null
        sleep 2
    fi
}

function _CalidadImagen() {
    _Logo
    echo -e "$G AJUSTAR CALIDAD - $FILE$RE"
    echo -e "$Y Calidad actual: $(identify -format "%Q" "$RUTA/$FILE")/100$RE"
    
    echo -e "$G Ingresa nueva calidad (1-100):$RE"
    read -p " >> " calidad
    
    if ! [[ "$calidad" =~ ^[0-9]+$ ]] || [ "$calidad" -lt 1 ] || [ "$calidad" -gt 100 ]; then
        echo -e $R"Calidad inválida. Usa valor 1-100$RE"
        sleep 2
        _CalidadImagen
        return
    fi
    
    tempfile="${FILE%.*}_calidad.${FILE##*.}"
    
    if convert "$RUTA/$FILE" -quality "$calidad" "$RUTA/$tempfile"; then
        mv "$RUTA/$tempfile" "$RUTA/$FILE"
        echo -e "$G¡Calidad ajustada!$RE"
        sleep 1
    else
        echo -e $R"Error al ajustar calidad$RE"
        rm -f "$RUTA/$tempfile" 2>/dev/null
        sleep 2
    fi
}

function _ExtraerAudioVideo() {
    _Logo
    echo -e "$G EXTRAER AUDIO DE VIDEO - $FILE$RE"
    echo -e "$Y Selecciona formato:$G"
    echo -e "  $R[$Y 1$R ]$G MP3 (calidad estándar)"
    echo -e "  $R[$Y 2$R ]$G WAV (calidad sin pérdida)"
    echo -e "  $R[$Y 3$R ]$G Opus (tamaño pequeño)"
    read -p " >> " AUDIO_OPT

    case $AUDIO_OPT in
        1) formato="mp3"; codec="libmp3lame"; calidad="-b:a 192k" ;;
        2) formato="wav"; codec="pcm_s16le"; calidad="" ;;
        3) formato="opus"; codec="libopus"; calidad="-b:a 64k" ;;
        *) echo -e $R"Opción inválida$RE"; sleep 1; return ;;
    esac

    audiofile="${FILE%.*}_audio.$formato"
    
    ffmpeg -i "$RUTA/$FILE" -vn -c:a $codec $calidad "$RUTA/$audiofile" > /dev/null 2>&1
    
    if [ $? -eq 0 ]; then
        echo -e "$G¡Audio extraído! Guardado como: $audiofile$RE"
        sleep 2
    else
        echo -e $R"Error al extraer audio$RE"
        rm -f "$RUTA/$audiofile" 2>/dev/null
        sleep 2
    fi
}


function _About(){
	clear
	echo -e $G"
	            C O N V E R T E R
		           by
		</[M]iLu{×}_> | DNP | 2024

   CONVERTER$RE Creado para DNP (Developer New Programmers)
              Desarrollado por$G </[M]iLu{×}_>$RE
        para el canal$G https://t.me/Ivam3by_Cinderella$RE
	        bot ayuda$G https://t.me/Ivam3_Bot$RE
	
      	  Este script esta creado para facilitar
        el cambio de formatos multimedia, utilizando
    FFMPEG e Imagemagick  para su correcto funcionamiento

		¡GRACIAS POR INSTALAR CONVERTER!
  $C             </[M]iLu{×}_>$G https://t.me/miluxmil$RE
    "
    read -n 1 -p "ENTER To Continue.."
    bash $0
}

function _Update() {
    _Logo
    mkdir -p ~/.milux
    [ ! -f ~/.milux/cav.mlx ] && echo "V-2.0" > ~/.milux/cav.mlx
    
    echo -e $G"Espera mientras busco la última versión"
    sleep 2
    
    curl -s -o ~/.milux/ccv.mlx https://raw.githubusercontent.com/miluxmil/milux/master/CCV
    CAV=$(cat ~/.milux/ccv.mlx)
    CCV=$(cat ~/.milux/cav.mlx)
    
    if [ "$CAV" == "$CCV" ]; then
        _Logo
        echo -e $G"Tienes la última versión$RE"
        sleep 2
    else
        _Logo
        echo -e $G"Nueva versión encontrada!\nActualizando..."
        sleep 2
        PW=$(pwd)
        cd ~/.milux/
        curl -s -o converter https://raw.githubusercontent.com/miluxmil/milux/master/converter
        chmod 777 converter
        mv converter $PREFIX/bin/
        cd $PW
        mv ~/.milux/ccv.mlx ~/.milux/cav.mlx
        _Logo
        echo -e $G"Actualizado correctamente"
        sleep 2
    fi
    bash $0
}

trap "ctl_c" SIGINT

#clear
for (( i=0; i<msg_len; i++ )); do
	echo -n "${message:$i:1}"
	sleep 0.01
done
echo;sleep 2
_Menu
