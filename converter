#!/data/data/com.termux/files/usr/bin/bash

#update 2024
#Functions
#imagemagick

C='\033[1;36m'
G='\033[1;32m'
R='\033[1;31m'
Y='\033[1;33m'
B='\033[1;34m'
P='\033[1;35m'
RE='\033[0m'


PROJECTS_DIR=~/ConverterProjects
CURRENT_PROJECT=""
PROJECT_CONFIG="project.cfg"
YEAR=2025
#trap "ctl_c" SIGINT
message="CONVERTER | Iniciando"
cols=$(stty size | awk '{print $2}')
msg_len=${#message}
center=$(( (cols - msg_len) / 2 ))
printf "\n%.0s" {1..5}
tput cuf $center
FORMATOS=$(ffmpeg -formats 2>/dev/null | grep E | awk '{print $2}';identify -list format | awk '{print $1}' | grep -v '^$' | sed 's/\*//g')
PROFILE_SELECTED=0

function _MainInit() {
    # Verificar dependencias solo si no se ha hecho antes
    if [ ! -f ~/.milux/deps_checked ]; then
        _CheckDependencies
        touch ~/.milux/deps_checked
    fi
    
}

function _CheckDependencies() {
    echo -e "$G VERIFICACIÓN DE DEPENDENCIAS$RE"
    echo -e "$Y Comprobando herramientas necesarias...$RE"
    
    # Lista de paquetes esenciales
    essential_pkgs=("ffmpeg" "mogrify" "curl")
    
    # Lista de paquetes recomendados
    recommended_pkgs=("jq" "rclone" "termux-notification" "wget" "git" "bc" "file" "less")
    
    # Lista de paquetes opcionales (para funcionalidades específicas)
    optional_pkgs=("python" "nodejs" "openssh" "rsync")
    
    # Verificar instalación de paquetes esenciales
    missing_essential=()
    for pkg in "${essential_pkgs[@]}"; do
        if ! command -v "$pkg" >/dev/null 2>&1; then
            missing_essential+=("$pkg")
        fi
    done
    
    # Verificar paquetes recomendados
    missing_recommended=()
    for pkg in "${recommended_pkgs[@]}"; do
        if ! command -v "$pkg" >/dev/null 2>&1; then
            missing_recommended+=("$pkg")
        fi
    done
    
    # Mostrar estado actual
    echo -e "$G ESTADO DE DEPENDENCIAS$RE"
    echo -e "$Y Esenciales:$RE"
    for pkg in "${essential_pkgs[@]}"; do
        if [[ " ${missing_essential[@]} " =~ " ${pkg} " ]]; then
            echo -e " - $pkg: $R FALTANTE$RE"
        else
            echo -e " - $pkg: $G INSTALADO$RE"
        fi
    done
    
    echo -e ""
    echo -e "$Y Recomendadas:$RE"
    for pkg in "${recommended_pkgs[@]}"; do
        if [[ " ${missing_recommended[@]} " =~ " ${pkg} " ]]; then
            echo -e " - $pkg: $C RECOMENDADO$RE"
        else
            echo -e " - $pkg: $G INSTALADO$RE"
        fi
    done
    
    # Instalar paquetes faltantes
    if [ ${#missing_essential[@]} -gt 0 ]; then
        echo -e ""
        echo -e "$R FALTAN DEPENDENCIAS ESENCIALES$RE"
        echo -e "$Y Se instalarán automáticamente:$RE"
        echo -e " - ${missing_essential[*]}"
        
        apt update -y && apt upgrade -y
        apt install -y "${missing_essential[@]}"
        
        # Verificar instalación después de intentar
        for pkg in "${missing_essential[@]}"; do
            if command -v "$pkg" >/dev/null 2>&1; then
                echo -e " - $pkg: $G INSTALADO$RE"
            else
                echo -e " - $pkg: $R ERROR AL INSTALAR$RE"
            fi
        done
    fi
    
    # Instalar paquetes recomendados si el usuario lo desea
    if [ ${#missing_recommended[@]} -gt 0 ]; then
        echo -e ""
        echo -e "$Y ¿Deseas instalar dependencias recomendadas?$RE"
        echo -e "$G Esto mejorará la experiencia con funciones avanzadas$RE"
        echo -e " - ${missing_recommended[*]}"
        
        read -p "Instalar? (s/n): " install_rec
        
        if [[ "$install_rec" =~ [sS] ]]; then
            apt install -y "${missing_recommended[@]}"
            
            # Verificar instalación
            for pkg in "${missing_recommended[@]}"; do
                if command -v "$pkg" >/dev/null 2>&1; then
                    echo -e " - $pkg: $G INSTALADO$RE"
                else
                    echo -e " - $pkg: $C NO INSTALADO$RE"
                fi
            done
        fi
    fi
    
    # Verificar configuraciones adicionales
    _CheckAdditionalConfigs
    
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _CheckAdditionalConfigs() {
    echo -e ""
    echo -e "$Y VERIFICACIÓN DE CONFIGURACIONES ADICIONALES$RE"
    
    # 1. Verificar rclone para Google Drive
    if command -v rclone >/dev/null; then
        if rclone listremotes | grep -q ":"; then
            echo -e " - Rclone: $G CONFIGURADO$RE"
        else
            echo -e " - Rclone: $C NO CONFIGURADO (ejecuta 'rclone config')$RE"
        fi
    else
        echo -e " - Rclone: $C NO INSTALADO$RE"
    fi
    
    # 2. Verificar acceso a termux-api
    if command -v termux-notification >/dev/null; then
        if termux-battery-status >/dev/null 2>&1; then
            echo -e " - Termux API: $G FUNCIONAL$RE"
        else
            echo -e " - Termux API: $R ERROR (verifica permisos)$RE"
        fi
    else
        echo -e " - Termux API: $C NO INSTALADO$RE"
    fi
    
    # 3. Verificar directorio de trabajo
    if [ -d ~/.milux ]; then
        echo -e " - Directorio de trabajo: $G CONFIGURADO$RE"
    else
        mkdir -p ~/.milux
        echo -e " - Directorio de trabajo: $C CREADO$RE"
    fi
    
    # 4. Verificar acceso a almacenamiento externo
    if [ -d /sdcard ]; then
        echo -e " - Almacenamiento externo: $G ACCESIBLE$RE"
    else
        echo -e " - Almacenamiento externo: $R INACCESIBLE (ejecuta 'termux-setup-storage')$RE"
    fi
    
    # 5. Verificar versión de FFmpeg
    ffmpeg_version=$(ffmpeg -version | head -n1 | awk '{print $3}')
    if [[ "$ffmpeg_version" =~ ^7 ]]; then
        echo -e " - FFmpeg: $G v$ffmpeg_version (excelente)$RE"
    elif [[ "$ffmpeg_version" =~ ^6 ]]; then
        echo -e " - FFmpeg: $B v$ffmpeg_version (suficiente)$RE"
    else
        echo -e " - FFmpeg: $R v$ffmpeg_version (actualiza si es posible)$RE"
    fi
    
    # 6. Verificar repositorio GitHub para actualizaciones
    if curl -s --head https://github.com/miluxmil/milux/blob/master/converter | head -n1 | grep "200" >/dev/null; then
        echo -e " - Repositorio GitHub: $G ACCESIBLE$RE"
    else
        echo -e " - Repositorio GitHub: $C INACCESIBLE$RE"
    fi
}

_MainInit

function _Logo {
        clear
        echo -e "$P"
echo -e "
      \_/
     (* *)
    __)#(__
   ( )...( )(_)  $G C O N V E R T E R$P
   || |_| ||//     $G      By$P
>==() | | ()/      $G </[M]iLu{×}_> | DNP | $YEAR $P
    _(___)_
   [-]   [-]  $RE      Music - Video - Images
   "   

}

function ctl_c(){
_Logo
echo -e "$G Saliendo de Converter...";sleep 0.5
_Logo
echo -e "OK, BYE BYE!";exit

}


spin () {
local pid=$!
local delay=0.25
local spinner=( '█■■■■■' '■█■■■■' '■■█■■■' '■■■█■■' '■■■■█■' '■■■■■█' )

while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do

	for i in "${spinner[@]}"
	do
		tput civis
		echo -ne "\033[1;33m\r Convirtiendo, ten paciencia......\e[33m[\033[32m$i\033[33m]\033[0m   ";
		sleep $delay
		printf "\b\b\b\b\b\b\b\b";
	done
done
printf "   \b\b\b\b\b"
tput cnorm
_Logo
printf "\033[1;33m [\e[1;36m Conversion OK..\033[1;33m ]\e\n";sleep 1;
echo "";
}

function _Menu() {
	CCV=$(cat ~/.milux/cav.mlx 2>/dev/null || echo "V-2.0")
	_Logo
echo -e $G"Elije una opcion

	[$RE 1$G ]$Y Audio $G
	[$RE 2$G ]$Y Imagen $G
	[$RE 3$G ]$Y Video $G
	[$RE 4$G ]$Y Extraer audio $G
	[$RE 5$G ]$Y Perfiles preconfigurados $G
	[$RE 6$G ]$Y Gestionar Almacenamiento $G
	[$RE 7$G ]$Y Modo avanzado $G
	[$RE 8$G ]$Y Descargar de internet $G
	[$RE 9$G ]$Y Subir a la nube$G
	[$RE 10$G ]$Y Configurar servicios nube$G
	[$RE 11$G ]$Y Centro de notificaciones$G
	[$RE 12$G ]$Y Verificar dependencias$G
	[$RE 13$G ]$Y Acerca de.. $G
	[$RE 00$G ]$Y Actualizar..$G
	[$RE 0$G ]$Y Salir $G
	"
	while read -p "-Milux- Convert $CCV >> " OPT && [ -z "$OPT" ];do
	echo -e $R"[!]$Y Debes ingresar una opcion valida    $RE";sleep 1;_Menu
done
	case $OPT in
		1)
			MODE="- Audio -";FR1=mp3;FR2=wma;FR3=ogg
			_Main
			;;
		2)
			MODE="- Imagen -";FR1=jpeg;FR2=png;FR3=jpg
			_Main
			;;
		3)
			MODE="- Video -";FR1=avi;FR2=wmv;FR3=mp4
			_Main
			;;
		4)
			MODE="- Extraer Audio -";FR1=mp3;FR2=wav;FR3=ogg
			_Main
			;;
		5)
			_Profiles
			;;
		6)
        		_StorageManager
			;;
		7)
			_AdvancedMode
			;;
		8)
			_InternetDownload
			;;
		9)
			echo -e "$Y Ingresa la ruta del archivo a subir:$RE"
            read -p " >> " upload_file
            if [ -f "$upload_file" ]; then
                _CloudUpload "$upload_file"
            else
                _SendNotification "Subida Nube" "Archivo no encontrado" "high"
            fi
	    ;;
 	   	10)
			_CloudSetup
			;;
		11)
			_NotificationCenter
			;;
		12)

			rm ~/.milux/deps_checked
			_MainInit
			_Menu

			;;
		13)
			_About
			;;
		00)
			_Update
			;;
		0)
			ctl_c
			;;
		*)
			echo -e $R"Opción inválida"; sleep 1; _Menu
			;;
	esac

}


function _Main() { 
_Logo
echo -e $G"Escribe la ruta donde se encuentra\ntu archivo a convertir$RE Ejem.:$R /sdcard/MiFolder$RE"

while read -p "$MODE >> " RUTA && [ -z "$RUTA" ];do
	echo -e $R"[!]$Y Debes ingresar una ruta valida
$RE"
done

if [ "$RUTA" = "mi" ];then
	RUTA="/sdcard/youtube"
fi

ls "$RUTA" > /dev/null 2>&1;C1=$?

if [ "$C1" = "0" ];then
	_Continue
else
	echo -e $R"[!]$Y Ruta no existe, verificala$RE";sleep 3
	bash "$0"
fi
}

function _Continue() {
    _Logo
    echo -e "$G Estas ubicado en:$RE $RUTA"
    # Listar archivos numerados
    local count=1
    FILES=()
    for file in "$RUTA"/*; do
        if [ -f "$file" ]; then
            echo -e "${R}[${RE} $count ${R}]${G} $(basename "$file")${RE}"
            FILES+=("$(basename "$file")")
            ((count++))
        fi
    done

    echo -e $G"
$R[$Y r$R ]$G REFRESH   $R[$Y d$R ]$G DELETE
$R[$Y p$R ]$G NEW PATH  $R[$Y n$R ]$G NEW CONVERSION
$R[$Y c$R ]$G COPY      $R[$Y m$R ]$G MOVE  
"
    while read -p "Selecciona una o varias opciones 
Separadas por un espacio >> " -a OPTION && [ -z "${OPTION[*]}" ]; do
        echo -e $R"[!]$Y Debes ingresar una opcion$RE"
    done

    # Manejar comandos especiales
    if [ ${#OPTION[@]} -eq 1 ]; then
        case "${OPTION[0]}" in
            r|R)
                _Continue
                return
                ;;
            d|D)
                CM="rm -rf"
                _CopyMoveDel "$RUTA"
                return
                ;;
            p|P)
                _Main
                return
                ;;
            n|N)
                _Menu
                return
                ;;
            c|C)
                CM="cp -r"
                _CopyMoveDel "$RUTA"
                return
                ;;
            m|M)
                CM="mv"
                _CopyMoveDel "$RUTA"
                return
                ;;
        esac
    fi

    # Procesar selección de archivos
    _Check
}

function _CopyMoveDel(){
	local RUTA=$1
	_Logo
    local count=1
    FILES=()
    for file in "$RUTA"/*; do
        if [ -f "$file" ]; then
            echo -e "${R}[${RE} $count ${R}]${G} $(basename "$file")${RE}"
            FILES+=("$(basename "$file")")
            ((count++))
        fi
    done
	 echo -e "$G"
	 
	 if [ "$CM" = "cp -r" ];then
		 CME="copiar"
	elif [ "$CM" = "mv" ];then
		CME="mover"
	elif [ "$CM" = "rm -rf" ];then
		CME="eliminar"
	 fi

	read -p "Selecciona archivos a $CME (números), separados por espacios. 
	>> " -a OPTIONS
	if [ "$CM" = "cp -r" ] || [ "$CM" = "mv" ];then
        read -p "Escribe la ruta destino >> " COPY
        mkdir -p "$COPY" 2>/dev/null
	fi

    local selected_files=()
    for INDEX in "${OPTIONS[@]}"; do
        if [ "$INDEX" -le "${#FILES[@]}" ] && [ "$INDEX" -gt 0 ]; then
            selected_files+=("${FILES[$((INDEX-1))]}")
        fi
    done

    for FILE in "${selected_files[@]}"; do
        echo "$CME $FILE..."
        if [ "$CM" = "rm -rf" ]; then
            $CM "$RUTA/$FILE"
        else
            $CM "$RUTA/$FILE" "$COPY"
        fi
    done
    _Continue
}

function _Music() {
    for FILE in "${FILES[@]}"; do
        _Logo
        echo -e $G"Archivo:$Y "$FILE"" 
        
        # Preguntar por metadatos
        read -p "¿Agregar metadatos? (s/n): " ADD_METADATA
        if [[ "$ADD_METADATA" =~ [sS] ]]; then
            read -p "Título: " TITLE
            read -p "Artista: " ARTIST
            read -p "Álbum: " ALBUM
            
            ffmpeg -i "$RUTA/$FILE" \
                -metadata title="$TITLE" \
                -metadata artist="$ARTIST" \
                -metadata album="$ALBUM" \
                -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
        else
		_SendNotification "Conversión Audio" "Procesando: $FILE"
            ffmpeg -i "$RUTA/$FILE" -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
	    _SendNotification "Conversión Audio" "Completado: ${FILE%.*}.$EXIT"
        fi
    done
    _Part2    
}

function _Image(){
    for FILE in "${FILES[@]}"; do
        _Logo
        echo -e $G"Convirtiendo: $Y $FILE"
        mogrify -format $EXIT -path "$RUTA" "$RUTA/$FILE" > /dev/null 2>&1 & spin
    done
    _Part2
}

function _Video(){
    for FILE in "${FILES[@]}"; do
        _Logo
        echo -e $G"Convirtiendo: $Y $FILE"
        if [ "$PROFILE_SELECTED" -eq 1 ]; then
            ffmpeg -i "$RUTA/$FILE" -c:v $VIDEO_CODEC -c:a $AUDIO_CODEC \
                -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
        else
            ffmpeg -i "$RUTA/$FILE" -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
        fi
    done
    _Part2
} 

function _ExtractAudio() {
    AUDIO_QUALITY="192k"
    for FILE in "${FILES[@]}"; do
        _Logo
        echo -e $G"Extrayendo audio de:$Y "$FILE"" 
        ffmpeg -i "$RUTA/$FILE" -vn -ab $AUDIO_QUALITY -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
    done
    _Part2
}

function _Part2(){
_Logo
echo -e $G"¿Que hago con archivos originales?

[$RE 1$G ]$Y Conservar$G
[$RE 2$G ]$Y Eliminar$G
[$RE 3$G ]$Y Eliminar antiguos y Mover nuevos$G
"
while read -p "$MODE >> " WDO && [ -z "$WDO" ];do
	echo -e $R"[!]$Y Debes ingresar una opcion valida    $RE"
done

if [ "$WDO" = "1" ];then
	_OK
	_Continue

elif [ "$WDO" = "2" ];then
	for FILE in "${FILES[@]}"; do
		rm -f "$RUTA/$FILE"
	done
	_OK
	_Continue

elif [ "$WDO" = "3" ];then
	while read -p "Ingresa la ruta destino >> " DEST && [ -z "$DEST" ];do
		echo -e $R"[!]$Y Debes ingresar una ruta valida    $RE"
	done

	if [ "$DEST" = "sp" ];then
		DEST="/sdcard/youtube/spotify"
	fi

	mkdir -p "$DEST" > /dev/null 2>&1
	if [ $? -eq 0 ]; then
        for FILE in "${FILES[@]}"; do
            rm -f "$RUTA/$FILE"
            echo -e $RE"Moviendo:$Y ${FILE%.*}.$EXIT";sleep 0.2
            mv -f "$RUTA/${FILE%.*}".$EXIT "$DEST" 2>/dev/null
        done
        _Continue
    else
        _Logo
        echo -e $R"Error al crear directorio destino"
        sleep 2
        _Part2
    fi
else
	echo -e $R"[!]$Y Opcion invalida$RE";sleep 3
    _Part2
fi
}

function _Check() {
    FILES_TO_PROCESS=()
    for INDEX in "${OPTION[@]}"; do
        if [ "$INDEX" -le "${#FILES[@]}" ] && [ "$INDEX" -gt 0 ]; then
            FILE_NAME="${FILES[$((INDEX-1))]}"
            FILES_TO_PROCESS+=("$FILE_NAME")
            FORMATO_ARCHIVO="${FILE_NAME##*.}"
            
            if ! echo "$FORMATOS" | grep -q "^$FORMATO_ARCHIVO$"; then
                _Logo
                echo -e $R"Archivo incompatible:$Y $FILE_NAME"
                sleep 3
                _Continue
                return
            fi
        fi
    done

    FILES=("${FILES_TO_PROCESS[@]}")

    _Logo
    echo -e "$Y Ingresa el formato de salida,$RE Ejemplo:$C $FR1, $FR2, $FR3 etc.$RE"
    read -p " -Milux- convert >> " EXIT

    while [ -z "$EXIT" ]; do
        echo -e $R"[X]$Y No escribiste nada o Formato incompatible $RE"
        read -p " -Milux- convert >> " EXIT
    done

    _Logo
    echo -e $G"La informacion, es correcta? s/n
$G Archivo(s):$RE"

    for FILE in "${FILES[@]}"; do
        echo -e "$FILE"
    done

    echo -e $G"Formato:$Y $EXIT $RE"
    read -p " S o N >> " SINO

      if [ "$SINO" = "s" ] || [ "$SINO" = "S" ]; then
        # Preguntar si desea editar
        read -p "¿Deseas editar el archivo antes de convertir? (s/n) " EDITAR
        if [[ "$EDITAR" =~ [sS] ]]; then
            for FILE in "${FILES[@]}"; do
                _Editor
            done
    	fi

    case "$MODE" in
        "- Audio -") _Music ;;
        "- Imagen -") _Image ;;
        "- Video -") _Video ;;
        "- Extraer Audio -") _ExtractAudio ;;
        "- Perfil preconfigurado Audio Whatsapp-"|"- Perfil preconfigurado Audio Spotify-"|"- Perfil preconfigurado Instagram -")
            _ProfilesConversion
            ;;
    esac
else
	_Continue
	return
      fi
}

function _ProfilesConversion() {
    case "$MODE" in
        "- Perfil preconfigurado Audio Whatsapp-")
            for FILE in "${FILES[@]}"; do
                ffmpeg -i "$RUTA/$FILE" -c:a libopus -b:a $AUDIO_QUALITY \
                    -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
            done
            ;;
        "- Perfil preconfigurado Audio Spotify-")
            for FILE in "${FILES[@]}"; do
                ffmpeg -i "$RUTA/$FILE" \
                    -metadata title="$TITLE" \
                    -metadata artist="$ARTIST" \
                    -metadata album="$ALBUM" \
                    -b:a $AUDIO_QUALITY \
                    -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
            done
            ;;
        "- Perfil preconfigurado Instagram -")
            for FILE in "${FILES[@]}"; do
                ffmpeg -i "$RUTA/$FILE" \
                    -c:v $VIDEO_CODEC \
                    -c:a $AUDIO_CODEC \
                    -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
            done
            ;;
    esac
    _Part2
}

function _Profiles() {
    _Logo
    echo -e $G"Selecciona un perfil:"
    echo -e "[$RE 1$G ]$Y WhatsApp (audio: opus)$G"
    echo -e "[$RE 2$G ]$Y Spotify (audio: mp3 256k con metadatos)$G"
    echo -e "[$RE 3$G ]$Y Instagram (video: mp4 H.264)$G"
    echo -e "[$RE 4$G ]$Y Volver al menú principal$RE"
    
    while read -p " >> " PROFILE_OPT && [ -z "$PROFILE_OPT" ]; do
        echo -e $R"Selecciona una opción válida"
    done
    
    case $PROFILE_OPT in
        1)
            _WhatsappProfile
            ;;
        2)
            _SpotifyProfile
            ;;
        3)
            _InstagramProfile
            ;;
        4)
            _Menu
            ;;
        *)
            echo -e $R"Opción inválida, intenta de nuevo"
            sleep 1
            _Profiles
            ;;
    esac
}

function _WhatsappProfile() {
    MODE="- Perfil Whatsapp -"
    EXIT="opus"
    AUDIO_QUALITY="64k"
    _ProfileMain
}

function _SpotifyProfile() {
    MODE="- Perfil Spotify -"
    EXIT="mp3"
    AUDIO_QUALITY="256k"
    _ProfileMain
}

function _InstagramProfile() {
    MODE="- Perfil Instagram -"
    EXIT="mp4"
    VIDEO_CODEC="libx264"
    AUDIO_CODEC="aac"
    _ProfileMain
}

function _ProfileMain() { 
    _Logo
    echo -e $G"Escribe la ruta donde se encuentran los archivos\n$RE Ejemplo:$R /sdcard/MisAudios$RE"

    while read -p "$MODE >> " RUTA && [ -z "$RUTA" ]; do
        echo -e $R"[!]$Y Debes ingresar una ruta válida$RE"
    done

    if [ "$RUTA" = "mi" ]; then
        RUTA="/sdcard/youtube"
    fi

    ls "$RUTA" > /dev/null 2>&1
    if [ $? -ne 0 ]; then
        echo -e $R"[!]$Y Ruta no existe, verifícala$RE"; sleep 3
        _ProfileMain
    else
        _ProfileContinue
    fi
}

function _ProfileContinue() {
    _Logo
    echo -e "$G Estás ubicado en:$RE $RUTA"
    echo -e "$G Perfil seleccionado:$Y $MODE$RE"
    echo -e "$G Formato de salida:$Y $EXIT$RE"
    
    # Listar archivos
    local count=1
    FILES=()
    for file in "$RUTA"/*; do
        if [ -f "$file" ]; then
            echo -e "${R}[${RE} $count ${R}]${G} $(basename "$file")${RE}"
            FILES+=("$(basename "$file")")
            ((count++))
        fi
    done

    echo -e $G"
$R[$Y a$R ]$G SELECCIONAR TODOS  $R[$Y r$R ]$G REFRESCAR
$R[$Y p$R ]$G NUEVA RUTA        $R[$Y m$R ]$G VOLVER AL MENÚ
"
    read -p "Selecciona archivos (números) separados por espacios >> " -a OPTIONS
    
    if [[ "${OPTIONS[*]}" == *a* ]] || [[ "${OPTIONS[*]}" == *A* ]]; then
        # Seleccionar todos los archivos
        SELECTED_FILES=("${FILES[@]}")
    elif [[ "${OPTIONS[*]}" == *r* ]] || [[ "${OPTIONS[*]}" == *R* ]]; then
        _ProfileContinue
        return
    elif [[ "${OPTIONS[*]}" == *p* ]] || [[ "${OPTIONS[*]}" == *P* ]]; then
        _ProfileMain
        return
    elif [[ "${OPTIONS[*]}" == *m* ]] || [[ "${OPTIONS[*]}" == *M* ]]; then
        _Menu
        return
    else
        # Procesar selección manual
        SELECTED_FILES=()
        for INDEX in "${OPTIONS[@]}"; do
            if [[ $INDEX =~ ^[0-9]+$ ]] && [ "$INDEX" -le "${#FILES[@]}" ] && [ "$INDEX" -gt 0 ]; then
                SELECTED_FILES+=("${FILES[$((INDEX-1))]}")
            fi
        done
    fi

    if [ ${#SELECTED_FILES[@]} -eq 0 ]; then
        echo -e $R"[!] No seleccionaste ningún archivo$RE"
        sleep 1
        _ProfileContinue
        return
    fi

    FILES=("${SELECTED_FILES[@]}")
    
    # Confirmar conversión
    _Logo
    echo -e "$G Archivos seleccionados:$Y"
    for FILE in "${FILES[@]}"; do
        echo "- $FILE"
    done
    
    echo -e $G"
Perfil: $Y$MODE
Formato: $Y$EXIT
$R[$Y s$R ]$G INICIAR CONVERSIÓN
$R[$Y n$R ]$G CANCELAR Y VOLVER
"
    read -p " >> " CONFIRM
    
    if [[ "$CONFIRM" =~ [sS] ]]; then
        _ProcessProfileConversion
    else
        _ProfileContinue
    fi
}

function _ProcessProfileConversion() {
    case "$MODE" in
        "- Perfil Whatsapp -")
            for FILE in "${FILES[@]}"; do
                _Logo
                echo -e $G"Convirtiendo a WhatsApp Audio:$Y $FILE"
                ffmpeg -i "$RUTA/$FILE" -c:a libopus -b:a $AUDIO_QUALITY \
                    -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
            done
            ;;
            
        "- Perfil Spotify -")
            for FILE in "${FILES[@]}"; do
                _Logo
                echo -e $G"Convirtiendo a Spotify:$Y $FILE"
                read -p "Título: " TITLE
                read -p "Artista: " ARTIST
                read -p "Álbum: " ALBUM
                
                ffmpeg -i "$RUTA/$FILE" \
                    -metadata title="$TITLE" \
                    -metadata artist="$ARTIST" \
                    -metadata album="$ALBUM" \
                    -b:a $AUDIO_QUALITY \
                    -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
            done
            ;;
            
        "- Perfil Instagram -")
            for FILE in "${FILES[@]}"; do
                _Logo
                echo -e $G"Convirtiendo a Instagram:$Y $FILE"
                ffmpeg -i "$RUTA/$FILE" \
                    -c:v $VIDEO_CODEC \
                    -c:a $AUDIO_CODEC \
                    -y "$RUTA/${FILE%.*}".$EXIT > /dev/null 2>&1 & spin
            done
            ;;
    esac
    
    _ProfilePart2
}

function _ProfilePart2() {
    _Logo
    echo -e $G"Conversión completada!$RE"
    echo -e "$Y Archivos convertidos:$G"
    for FILE in "${FILES[@]}"; do
        echo "- ${FILE%.*}.$EXIT"
    done
    
    echo -e $G"
¿Qué deseas hacer con los originales?
$R[$Y 1$R ]$G CONSERVAR ORIGINALES
$R[$Y 2$R ]$G ELIMINAR ORIGINALES
$R[$Y 3$R ]$G MOVER A CARPETA DIFERENTE
$R[$Y 4$R ]$G VOLVER AL MENÚ PRINCIPAL
"
    read -p " >> " OPT
    
    case $OPT in
        1)
            echo -e $G"Originales conservados en:$Y $RUTA$RE"
            sleep 2
            _Menu
            ;;
        2)
            for FILE in "${FILES[@]}"; do
                rm -f "$RUTA/$FILE"
            done
            echo -e $G"Originales eliminados$RE"
            sleep 2
            _Menu
            ;;
        3)
            read -p "Ruta destino para originales: " DEST
            mkdir -p "$DEST" 2>/dev/null
            if [ $? -eq 0 ]; then
                for FILE in "${FILES[@]}"; do
                    mv -f "$RUTA/$FILE" "$DEST/"
                done
                echo -e $G"Originales movidos a:$Y $DEST$RE"
            else
                echo -e $R"Error al crear directorio destino"
            fi
            sleep 2
            _Menu
            ;;
        *)
            _Menu
            ;;
    esac
}

function _OK() {
	_Logo
	echo -e "$Y Convertido correctamente!\n Guardado como...$G"
	for FILE in "${FILES[@]}"; do
		echo -e "${FILE%.*}.$EXIT"
	done
    echo -e $Y"En:$G $RUTA $RE"
    read -n 1 -p "ENTER To continue.."
    _Continue
}

function _Editor() {
    _Logo
    echo -e "$G EDITOR MULTIMEDIA - $FILE$RE"
    echo -e "$Y Selecciona una operación:$G"
    
    # Determinar tipo de archivo
    if file "$RUTA/$FILE" | grep -q "Audio"; then
        tipo="audio"
    elif file "$RUTA/$FILE" | grep -q "Video"; then
        tipo="video"
    else
        tipo="Imagen"
    fi

    # Menú según tipo
    case $tipo in
        "audio")
            echo -e "  $R[$Y 1$R ]$G Recortar audio"
            echo -e "  $R[$Y 2$R ]$G Normalizar volumen"
            echo -e "  $R[$Y 3$R ]$G Aplicar fade in/out"
            ;;
        "video")
            echo -e "  $R[$Y 1$R ]$G Recortar video"
            echo -e "  $R[$Y 2$R ]$G Rotar video"
            echo -e "  $R[$Y 3$R ]$G Redimensionar video"
            echo -e "  $R[$Y 4$R ]$G Extraer audio"
            ;;
        "imagen")
            echo -e "  $R[$Y 1$R ]$G Redimensionar imagen"
            echo -e "  $R[$Y 2$R ]$G Rotar imagen"
            echo -e "  $R[$Y 3$R ]$G Ajustar calidad"
            ;;
    esac
    
    echo -e "  0) Continuar sin editar"
    read -p " >> " EDIT_OPT

    case $EDIT_OPT in
        1)
            if [ "$tipo" = "audio" ] || [ "$tipo" = "video" ]; then
                _Recortar
            elif [ "$tipo" = "imagen" ]; then
                _RedimensionarImagen
            fi
            ;;
        2)
            if [ "$tipo" = "audio" ]; then
                _NormalizarAudio
            elif [ "$tipo" = "video" ]; then
                _RotarVideo
            elif [ "$tipo" = "imagen" ]; then
                _RotarImagen
            fi
            ;;
        3)
            if [ "$tipo" = "audio" ]; then
                _FadeAudio
            elif [ "$tipo" = "video" ]; then
                _RedimensionarVideo
            elif [ "$tipo" = "imagen" ]; then
                _CalidadImagen
            fi
            ;;
        4)
            if [ "$tipo" = "video" ]; then
                _ExtraerAudioVideo
            fi
            ;;
        0)
            return
            ;;
        *)
            echo -e $R"Opción inválida$RE"
            sleep 1
            _Editor
            ;;
    esac
}

function _Recortar() {
    _Logo
    echo -e "$G RECORTAR $FILE$RE"
    
    # Obtener duración del archivo
    duracion=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$RUTA/$FILE")
    minutos=$(printf "%02d" $(( ${duracion%.*} / 60 )))
    segundos=$(printf "%02d" $(( ${duracion%.*} % 60 )))
    
    echo -e "$Y Duración total: $minutos:$segundos$RE"
    echo -e "$G Ingresa los tiempos en formato MM:SS$RE"
    
    read -p "Inicio (ej: 00:25): " inicio
    read -p "Fin (ej: 02:30): " fin
    
    # Convertir a segundos
    min_ini=${inicio%:*}; seg_ini=${inicio#*:}
    min_fin=${fin%:*}; seg_fin=${fin#*:}
    start=$((min_ini * 60 + seg_ini))
    end=$((min_fin * 60 + seg_fin))
    
    if [ $end -le $start ]; then
        echo -e $R"Tiempo final debe ser mayor que inicial$RE"
        sleep 2
        _Recortar
        return
    fi
    
    # Crear archivo temporal
    tempfile="${FILE%.*}_recortado.${FILE##*.}"
    
    if [ "$tipo" = "audio" ]; then
        ffmpeg -i "$RUTA/$FILE" -ss $start -to $end -c copy "$RUTA/$tempfile" > /dev/null 2>&1
    else
        ffmpeg -i "$RUTA/$FILE" -ss $start -to $end -c:v copy -c:a copy "$RUTA/$tempfile" > /dev/null 2>&1
    fi
    
    if [ $? -eq 0 ]; then
        mv "$RUTA/$tempfile" "$RUTA/$FILE"
        echo -e "$G¡Recorte exitoso!$RE"
        sleep 1
    else
        echo -e $R"Error al recortar$RE"
        rm -f "$RUTA/$tempfile" 2>/dev/null
        sleep 2
    fi
}

function _NormalizarAudio() {
    _Logo
    echo -e "$G NORMALIZAR VOLUMEN - $FILE$RE"
    echo -e "$Y Ajustando volumen a nivel óptimo..."
    
    tempfile="${FILE%.*}_normalizado.${FILE##*.}"
    
    ffmpeg -i "$RUTA/$FILE" -af loudnorm=I=-16:LRA=11:TP=-1.5 "$RUTA/$tempfile" > /dev/null 2>&1
    
    if [ $? -eq 0 ]; then
        mv "$RUTA/$tempfile" "$RUTA/$FILE"
        echo -e "$G¡Audio normalizado!$RE"
        sleep 1
    else
        echo -e $R"Error al normalizar$RE"
        rm -f "$RUTA/$tempfile" 2>/dev/null
        sleep 2
    fi
}

function _RotarVideo() {
    _Logo
    echo -e "$G ROTAR VIDEO - $FILE$RE"
    echo -e "$Y Selecciona la rotación:$G"
    echo -e "  $R[$Y 1$R ]$G 90° sentido horario"
    echo -e "  $R[$Y 2$R ]$G 90° sentido antihorario"
    echo -e "  $R[$Y 3$R ]$G 180° (voltear)"
    read -p " >> " ROT_OPT

    case $ROT_OPT in
        1) filter="transpose=1" ;;
        2) filter="transpose=2" ;;
        3) filter="transpose=2,transpose=2" ;;
        *) echo -e $R"Opción inválida$RE"; sleep 1; return ;;
    esac

    tempfile="${FILE%.*}_rotado.${FILE##*.}"
    
    ffmpeg -i "$RUTA/$FILE" -vf "$filter" -c:a copy "$RUTA/$tempfile" > /dev/null 2>&1
    
    if [ $? -eq 0 ]; then
        mv "$RUTA/$tempfile" "$RUTA/$FILE"
        echo -e "$G¡Video rotado!$RE"
        sleep 1
    else
        echo -e $R"Error al rotar$RE"
        rm -f "$RUTA/$tempfile" 2>/dev/null
        sleep 2
    fi
}

function _RedimensionarVideo() {
    _Logo
    echo -e "$G REDIMENSIONAR VIDEO - $FILE$RE"
    
    # Obtener resolución original
    resolucion=$(ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 "$RUTA/$FILE")
    echo -e "$Y Resolución actual: $resolucion$RE"
    
    echo -e "$G Ingresa nueva resolución (ej: 1280x720):$RE"
    read -p " >> " nueva_res
    
    if ! echo "$nueva_res" | grep -Eq "^[0-9]+x[0-9]+$"; then
        echo -e $R"Formato inválido. Usa ANCHOxALTO$RE"
        sleep 2
        _RedimensionarVideo
        return
    fi
    
    tempfile="${FILE%.*}_resized.${FILE##*.}"
    
    ffmpeg -i "$RUTA/$FILE" -vf "scale=$nueva_res" -c:a copy "$RUTA/$tempfile" > /dev/null 2>&1
    
    if [ $? -eq 0 ]; then
        mv "$RUTA/$tempfile" "$RUTA/$FILE"
        echo -e "$G¡Video redimensionado!$RE"
        sleep 1
    else
        echo -e $R"Error al redimensionar$RE"
        rm -f "$RUTA/$tempfile" 2>/dev/null
        sleep 2
    fi
}

function _RedimensionarImagen() {
    _Logo
    echo -e "$G REDIMENSIONAR IMAGEN - $FILE$RE"
    
    # Obtener resolución original
    resolucion=$(identify -format "%wx%h" "$RUTA/$FILE")
    echo -e "$Y Resolución actual: $resolucion$RE"
    
    echo -e "$G Ingresa nueva resolución (ej: 800x600) o porcentaje (ej: 50%):$RE"
    read -p " >> " nueva_res
    
    tempfile="${FILE%.*}_resized.${FILE##*.}"
    
    if mogrify -path "$RUTA" -resize "$nueva_res" -write "$RUTA/$tempfile" "$RUTA/$FILE"; then
        mv "$RUTA/$tempfile" "$RUTA/$FILE"
        echo -e "$G¡Imagen redimensionada!$RE"
        sleep 1
    else
        echo -e $R"Error al redimensionar$RE"
        rm -f "$RUTA/$tempfile" 2>/dev/null
        sleep 2
    fi
}

function _RotarImagen() {
    _Logo
    echo -e "$G ROTAR IMAGEN - $FILE$RE"
    echo -e "$Y Selecciona la rotación:$G"
    echo -e "  $R[$Y 1$R ]$G 90° derecha"
    echo -e "  $R[$Y 2$R ]$G 90° izquierda"
    echo -e "  $R[$Y 3$R ]$G 180°"
    echo -e "  $R[$Y 4$R ]$G Voltear horizontalmente"
    echo -e "  $R[$Y 5$R ]$G Voltear verticalmente"
    read -p " >> " ROT_OPT

    case $ROT_OPT in
        1) rotacion="-rotate 90" ;;
        2) rotacion="-rotate -90" ;;
        3) rotacion="-rotate 180" ;;
        4) rotacion="-flop" ;;
        5) rotacion="-flip" ;;
        *) echo -e $R"Opción inválida$RE"; sleep 1; return ;;
    esac

    tempfile="${FILE%.*}_rotada.${FILE##*.}"
    
    if convert "$RUTA/$FILE" $rotacion "$RUTA/$tempfile"; then
        mv "$RUTA/$tempfile" "$RUTA/$FILE"
        echo -e "$G¡Imagen rotada!$RE"
        sleep 1
    else
        echo -e $R"Error al rotar$RE"
        rm -f "$RUTA/$tempfile" 2>/dev/null
        sleep 2
    fi
}

function _CalidadImagen() {
    _Logo
    echo -e "$G AJUSTAR CALIDAD - $FILE$RE"
    echo -e "$Y Calidad actual: $(identify -format "%Q" "$RUTA/$FILE")/100$RE"
    
    echo -e "$G Ingresa nueva calidad (1-100):$RE"
    read -p " >> " calidad
    
    if ! [[ "$calidad" =~ ^[0-9]+$ ]] || [ "$calidad" -lt 1 ] || [ "$calidad" -gt 100 ]; then
        echo -e $R"Calidad inválida. Usa valor 1-100$RE"
        sleep 2
        _CalidadImagen
        return
    fi
    
    tempfile="${FILE%.*}_calidad.${FILE##*.}"
    
    if convert "$RUTA/$FILE" -quality "$calidad" "$RUTA/$tempfile"; then
        mv "$RUTA/$tempfile" "$RUTA/$FILE"
        echo -e "$G¡Calidad ajustada!$RE"
        sleep 1
    else
        echo -e $R"Error al ajustar calidad$RE"
        rm -f "$RUTA/$tempfile" 2>/dev/null
        sleep 2
    fi
}

function _ExtraerAudioVideo() {
    _Logo
    echo -e "$G EXTRAER AUDIO DE VIDEO - $FILE$RE"
    echo -e "$Y Selecciona formato:$G"
    echo -e "  $R[$Y 1$R ]$G MP3 (calidad estándar)"
    echo -e "  $R[$Y 2$R ]$G WAV (calidad sin pérdida)"
    echo -e "  $R[$Y 3$R ]$G Opus (tamaño pequeño)"
    read -p " >> " AUDIO_OPT

    case $AUDIO_OPT in
        1) formato="mp3"; codec="libmp3lame"; calidad="-b:a 192k" ;;
        2) formato="wav"; codec="pcm_s16le"; calidad="" ;;
        3) formato="opus"; codec="libopus"; calidad="-b:a 64k" ;;
        *) echo -e $R"Opción inválida$RE"; sleep 1; return ;;
    esac

    audiofile="${FILE%.*}_audio.$formato"
    
    ffmpeg -i "$RUTA/$FILE" -vn -c:a $codec $calidad "$RUTA/$audiofile" > /dev/null 2>&1
    
    if [ $? -eq 0 ]; then
        echo -e "$G¡Audio extraído! Guardado como: $audiofile$RE"
        sleep 2
    else
        echo -e $R"Error al extraer audio$RE"
        rm -f "$RUTA/$audiofile" 2>/dev/null
        sleep 2
    fi
}


function _StorageManager() {
    while true; do
        _Logo
        echo -e "$G GESTIÓN DE ALMACENAMIENTO$RE"
        
        # Obtener información de almacenamiento
        total=$(df -h /data | awk 'NR==2 {print $2}')
        usado=$(df -h /data | awk 'NR==2 {print $3}')
        libre=$(df -h /data | awk 'NR==2 {print $4}')
        porcentaje=$(df -h /data | awk 'NR==2 {print $5}')
        
        # Gráfico simple
        echo -e "$Y Almacenamiento: ${libre} libres de ${total} (${porcentaje} usado)$RE"
        echo -ne "$G ["
        for ((i=0; i<50; i++)); do
            if [ $i -lt $((${porcentaje%\%} / 2)) ]; then
                echo -ne "#"
            else
                echo -ne "-"
            fi
        done
        echo -e "]$RE"
        
        # Menú
        echo -e "
$R[$Y 1$R ]$G Analizar espacio por carpetas
$R[$Y 2$R ]$G Buscar archivos grandes (>50MB)
$R[$Y 3$R ]$G Limpiar archivos temporales
$R[$Y 4$R ]$G Organizar carpeta actual
$R[$Y 5$R ]$G Buscar archivos duplicados
$R[$Y 6$R ]$G Comprimir archivos
$R[$Y 7$R ]$G Liberar espacio de caché
$R[$Y 8$R ]$G Eliminar muertos
$R[$Y 0$R ]$G Volver al menú principal
        "
        
        read -p " >> " storage_opt
        
        case $storage_opt in
            1) _AnalyzeSpace ;;
            2) _FindLargeFiles ;;
            3) _CleanTempFiles ;;
            4) _OrganizeFolder ;;
            5) _FindDuplicates ;;
            6) _CompressFiles ;;
            7) _ClearCache ;;
	    8) _FindEmptyDirs ;;
            0) _Menu ;;
            *) echo -e $R"Opción inválida$RE"; sleep 1 ;;
        esac
    done
}

function _AnalyzeSpace() {
    _Logo
    echo -e "$G ANALIZAR ESPACIO EN DISCO$RE"
    echo -e "$Y Calculando... (puede tomar tiempo)$RE"
    
    # Analizar las 10 carpetas más grandes
    result=$(du -h --max-depth=1 /sdcard/ 2>/dev/null | sort -rh | head -n 11)
    
    _Logo
    echo -e "$G CARPETAS QUE OCUPAN MÁS ESPACIO:$RE"
    echo -e "$C$result$RE"
    
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _FindLargeFiles() {
    _Logo
    echo -e "$G BUSCANDO ARCHIVOS GRANDES$RE"
    
    # 1. Tamaño personalizable con validación
    while true; do
        echo -e "$Y Ingresa el tamaño mínimo (ej: 30M, 100M, 1G): $RE" 
	read -p ">> " min_size
        min_size=${min_size:-30M}
        [[ $min_size =~ ^[0-9]+[MGK]$ ]] && break
        echo -e "$R¡Formato incorrecto! Usa ejemplo: 30M o 1G$RE"
    done

    _Logo
    echo -e "$G BUSCANDO ARCHIVOS > $min_size $RE"
    echo -e "$Y Buscando...$RE"
    
    # 2. Búsqueda precisa con tamaño real
    mapfile -t large_files < <(
        find /sdcard/ -type f -size +$min_size -exec du -h {} + 2>/dev/null |
        sort -rh |
        head -n 50 |
        awk -F'\t' '{print $2}'
    )
    
    _Logo
    echo -e "$R ARCHIVOS ENCONTRADOS (>$min_size, ordenados por tamaño):$RE"
    
    if [ ${#large_files[@]} -eq 0 ]; then
        echo -e "$G No se encontraron archivos > $min_size $RE"
    else
        # 3. Mostrar lista con tamaños exactos
        for i in "${!large_files[@]}"; do
            size=$(du -h "${large_files[i]}" 2>/dev/null | cut -f1)
            echo -e "$R[$RE $((i+1)) $R]$Y ${large_files[i]} $G($size)$RE"
        done
        
        # 4. Eliminación segura
        echo -e "\n$G"
        read -p "¿Eliminar archivos? (ej: 1 3 5 / 0 para cancelar): " -a options
        
        for opt in "${options[@]}"; do
            if [[ "$opt" =~ ^[0-9]+$ ]] && [ "$opt" -le "${#large_files[@]}" ] && [ "$opt" -gt 0 ]; then
                file="${large_files[$((opt-1))]}"
                if rm -f -- "$file"; then
                    echo -e "$G✓ Eliminado: ${file##*/}$RE"
                else
                    echo -e "$R✗ Error eliminando: ${file##*/}$RE"
                fi
            fi
        done
    fi

    echo -e "$Y Presiona ENTER para continuar...$RE"
    read -n 1 
}

function _CleanTempFiles() {
    _Logo
    echo -e "$G LIMPIANDO ARCHIVOS TEMPORALES$RE"
    echo -e "$Y Buscando archivos temporales...$RE"
    
    # Buscar y eliminar archivos temporales comunes
    temp_files=0
    freed_space=0
    
    # Patrones de archivos temporales
    patterns=(
        "*.tmp"
        "*.temp"
        "*.bak"
	"*.swp"
        "*.cache"
        "*.log"
        "~*"
        "*.thumb"
        "*.crdownload"
    )
    
    for pattern in "${patterns[@]}"; do
        while IFS= read -r -d $'\0' file; do
            size=$(du -k "$file" | cut -f1)
            rm -f "$file"
            if [ ! -f "$file" ]; then
                temp_files=$((temp_files + 1))
                freed_space=$((freed_space + size))
            fi
        done < <(find /data /sdcard/ -type f -name "$pattern" -print0 2>/dev/null)
    done
    
    _Logo
    if [ $temp_files -gt 0 ]; then
        echo -e "$G ¡LIMPIEZA COMPLETADA!$RE"
        echo -e "$Y Archivos eliminados: $temp_files$RE"
        echo -e "$Y Espacio liberado: $((freed_space / 1024)) MB$RE"
    else
        echo -e "$Y No se encontraron archivos temporales para limpiar$RE"
    fi
    
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _OrganizeFolder() {
    _Logo
    echo -e "$G ORGANIZAR CARPETA$RE"
    echo -e "$Y Ingresa la ruta a organizar:$RE"
    read -p " >> " folder_path
    
    if [ ! -d "$folder_path" ]; then
        echo -e $R"La carpeta no existe$RE"
        sleep 2
        return
    fi
    
    echo -e "$Y Organizando: $folder_path$RE"
    
    # Crear carpetas por tipo
    declare -A folders=(
        ["Documentos"]="pdf|docx?|xlsx?|pptx?|txt|rtf|odt"
        ["Imágenes"]="jpg|jpeg|png|gif|bmp|webp"
        ["Audios"]="mp3|wav|flac|ogg|m4a"
        ["Videos"]="mp4|avi|mkv|mov|flv|wmv"
        ["Comprimidos"]="zip|rar|7z|tar|gz|iso"
        ["APKs"]="apk"
        ["Ejecutables"]="exe|sh|bin|deb"
    )
    
    for folder in "${!folders[@]}"; do
        mkdir -p "$folder_path/$folder"
    done
    
    # Mover archivos
    moved=0
    for file in "$folder_path"/*; do
        if [ -f "$file" ]; then
            filename=$(basename "$file")
            ext="${filename##*.}"
            
            for folder in "${!folders[@]}"; do
                if [[ "${folders[$folder]}" =~ (^|\|)$ext($|\|) ]]; then
                    mv "$file" "$folder_path/$folder/"
                    echo -e "$G - Movido: $filename => $folder/$RE"
                    moved=$((moved + 1))
                    break
                fi
            done
        fi
    done
    
    _Logo
    echo -e "$G ORGANIZACIÓN COMPLETADA!$RE"
    echo -e "$Y Archivos movidos: $moved$RE"
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _FindDuplicates() {
    _Logo
    echo -e "$G BUSCANDO ARCHIVOS DUPLICADOS$RE"
    echo -e "$Y Esta operación puede tomar tiempo...$RE"
    
    echo -e "$Y Ingresa la ruta a analizar:$RE"
    read -p " >> " search_path
    
    if [ ! -d "$search_path" ]; then
        echo -e $R"La carpeta no existe$RE"
        sleep 2
        return
    fi
    
    # Usar fdupes para mayor eficiencia
    if ! command -v fdupes > /dev/null; then
        echo -e "$Y Instalando fdupes para mejor rendimiento...$RE"
        pkg install -y fdupes > /dev/null 2>&1
    fi
    
    # Carpeta temporal para resultados
    temp_file="/data/data/com.termux/files/usr/tmp/duplicates_$RANDOM.txt"
    
    _Logo
    echo -e "$Y Buscando duplicados (esto puede llevar tiempo)...$RE"
    
    # Ejecutar búsqueda en segundo plano con barra de progreso
    (
        fdupes -r "$search_path" > "$temp_file" 2>/dev/null &
        pid=$!
        
        # Mostrar spinner mientras se ejecuta
        while kill -0 $pid 2>/dev/null; do
            for s in / - \\ \|; do
                printf "\rBuscando... $s"
                sleep 0.1
            done
        done
    )
    
    duplicates=$(grep -c '^$' "$temp_file")
    
    _Logo
    if [ "$duplicates" -eq 0 ]; then
        echo -e "$G No se encontraron archivos duplicados$RE"
        rm -f "$temp_file"
        read -n 1 -p "Presiona ENTER para continuar..."
        return
    fi
    
    echo -e "$Y Se encontraron $duplicates grupos de archivos duplicados$RE"
    read -p "¿Deseas ver los resultados? (s/n): " view_choice
    
    if [[ "$view_choice" =~ [sS] ]]; then
        # Mostrar primeros 5 grupos
        echo -e "$G Mostrando primeros 5 grupos de duplicados:$RE"
        awk 'BEGIN {RS=""; FS="\n"; count=1} 
            count<=5 {
                print "Grupo " count ":";
                for (i=1; i<=NF; i++) if ($i != "") print "  " $i;
                print "";
                count++
            }' "$temp_file"
    fi
    
    read -p "¿Deseas eliminar los duplicados? (s/n): " delete_choice
    
    if [[ "$delete_choice" =~ [sS] ]]; then
        _Logo
        echo -e "$Y Eliminando duplicados...$RE"
        
        # Método rápido de eliminación
        total_removed=0
        total_freed=0
        
        # 1. Limpiar archivo de tamaños antes de empezar
        > /data/data/com.termux/files/usr/tmp/sizes
        
        # 2. Usar while read para evitar subshell y capturar total_removed
        while IFS= read -r line; do
            printf "."
            ((total_removed++))
        done < <(
            # 3. Awk modificado sin variable interna
            awk 'BEGIN {RS=""; FS="\n"} {
                keep = ""
                for (i=1; i<=NF; i++) {
                    if ($i != "") {
                        if (keep == "") {
                            keep = $i
                        } else {
                            # Solo imprimir línea para contar
                            print "Eliminado: " $i
                            # Ejecutar comandos de eliminación
                            system("du -k \"" $i "\" | cut -f1 >> /data/data/com.termux/files/usr/tmp/sizes 2>/dev/null")
                            system("rm -f \"" $i "\"")
                        }
                    }
                }
            }' "$temp_file"
        )
        
        # Calcular espacio liberado
        if [ -f /data/data/com.termux/files/usr/tmp/sizes ]; then
            total_freed=$(awk '{sum+=$1} END {print sum}' /data/data/com.termux/files/usr/tmp/sizes)
            rm -f /data/data/com.termux/files/usr/tmp/sizes
        fi
        
        echo -e "\n$G ELIMINACIÓN COMPLETADA!$RE"
        echo -e "$Y Archivos eliminados: $total_removed$RE"
        echo -e "$Y Espacio liberado: $((total_freed / 1024)) MB$RE"
    else
        echo -e "$Y Conservando todos los archivos$RE"
    fi
    
    rm -f "$temp_file"
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _CompressFiles() {
    _Logo
    echo -e "$G COMPRESIÓN DE ARCHIVOS$RE"
    echo -e "$Y Ingresa la ruta donde están los archivos:$RE"
    read -p " >> " compress_path
    
    if [ ! -d "$compress_path" ]; then
        echo -e $R"La carpeta no existe$RE"
        sleep 2
        return
    fi
    
    # Guardar ruta original
    original_path="$compress_path"
    
    # Función para seleccionar archivos
    _SelectFilesToCompress() {
        while true; do
            _Logo
            echo -e "$G SELECCIONAR ARCHIVOS EN: $compress_path$RE"
            echo -e "$Y Selecciona archivos para comprimir:$G"
            
            # Listar archivos y directorios
            local count=1
            FILES_LIST=()
            for item in "$compress_path"/*; do
                if [ -e "$item" ]; then
                    name=$(basename "$item")
                    if [ -d "$item" ]; then
                        echo -e "${R}[${RE} $count ${R}]${C} [DIR] $name${RE}"
                    else
                        size=$(du -h "$item" | cut -f1)
                        echo -e "${R}[${RE} $count ${R}]${G} $name ${Y}($size)${RE}"
                    fi
                    FILES_LIST+=("$item")
                    ((count++))
                fi
            done
            
            echo -e "$G"
            echo -e "$R[$Y a$R ]$G SELECCIONAR TODOS"
            echo -e "$R[$Y d$R ]$G CAMBIAR DIRECTORIO"
            echo -e "$R[$Y f$R ]$G TERMINAR SELECCIÓN"
            echo -e "$R[$Y c$R ]$G CANCELAR"
            echo -e "$RE"
            
            read -p "Selecciona archivos (números separados por espacios): " -a selected
            
            case "${selected[0]}" in
                a|A)
                    # Seleccionar todos los archivos no directorios
                    SELECTED_FILES=()
                    for item in "${FILES_LIST[@]}"; do
                        if [ -f "$item" ]; then
                            SELECTED_FILES+=("$item")
                        fi
                    done
                    return
                    ;;
                d|D)
                    read -p "Nueva ruta: " compress_path
                    if [ ! -d "$compress_path" ]; then
                        echo -e $R"Directorio no existe$RE"
                        sleep 2
                        compress_path="$original_path"
                    fi
                    continue
                    ;;
                f|F)
                    if [ ${#SELECTED_FILES[@]} -gt 0 ]; then
                        return
                    else
                        echo -e $R"No has seleccionado ningún archivo$RE"
                        sleep 1
                    fi
                    ;;
                c|C)
                    SELECTED_FILES=()
                    return
                    ;;
            esac
            
            # Procesar selección numérica
            for index in "${selected[@]}"; do
                if [[ "$index" =~ ^[0-9]+$ ]] && [ "$index" -lt "$count" ] && [ "$index" -gt 0 ]; then
                    item="${FILES_LIST[$((index-1))]}"
                    
                    if [ -d "$item" ]; then
                        # Manejar directorio (explorar)
                        compress_path="$item"
                        _SelectFilesToCompress
                        compress_path="$original_path"
                    else
                        # Añadir archivo a selección
                        if [[ ! " ${SELECTED_FILES[@]} " =~ " ${item} " ]]; then
                            SELECTED_FILES+=("$item")
                            echo -e "$G Añadido: $(basename "$item")$RE"
                            sleep 0.3
                        fi
                    fi
                fi
            done
        done
    }
    
    # Iniciar selección
    SELECTED_FILES=()
    _SelectFilesToCompress
    
    # Verificar si se seleccionaron archivos
    if [ ${#SELECTED_FILES[@]} -eq 0 ]; then
        echo -e $R"No se seleccionaron archivos$RE"
        sleep 2
        return
    fi
    
    _Logo
    echo -e "$G ARCHIVOS SELECCIONADOS:$RE"
    for file in "${SELECTED_FILES[@]}"; do
        echo -e " - $Y$(basename "$file")$RE"
    done
    
    # Seleccionar formato de compresión
    echo -e "$G Selecciona el formato de compresión:"
    echo -e "[$RE 1$G ]$Y ZIP (compatible con todos)$G"
    echo -e "[$RE 2$G ]$Y TAR.GZ (mejor compresión)$G"
    echo -e "[$RE 3$G ]$Y 7Z (máxima compresión)$RE"
    read -p " >> " format_choice
    
    case $format_choice in
        1) extension="zip" ;;
        2) extension="tar.gz" ;;
        3) extension="7z" ;;
        *) echo -e $R"Opción inválida$RE"; return ;;
    esac
    
    echo -e "$Y Ingresa nombre para el archivo comprimido:$RE"
    read -p " >> " archive_name
    
    # Añadir extensión si no está presente
    if [[ ! "$archive_name" == *.$extension ]]; then
        archive_name="${archive_name}.${extension}"
    fi
    
    output_file="$original_path/$archive_name"
    
    _Logo
    echo -e "$Y Comprimiendo ${#SELECTED_FILES[@]} archivos...$RE"
    
    # Crear lista temporal de archivos
    file_list="/data/data/com.termux/files/usr/tmp/filelist_$RANDOM.txt"
    printf "%s\n" "${SELECTED_FILES[@]}" > "$file_list"
    
    # Ejecutar compresión según formato
    case $extension in
        "zip")
            # Comprimir manteniendo rutas relativas
            while read -r file; do
                relative_path="${file#$original_path/}"
                if [ -d "$file" ]; then
                    zip -r "$output_file" "$relative_path" > /dev/null
                else
                    zip -j "$output_file" "$file" > /dev/null
                fi
            done < "$file_list"
            ;;
        "tar.gz")
            # Crear archivo tar con rutas relativas
            tar -czf "$output_file" -C "$original_path" --files-from="$file_list" > /dev/null 2>&1
            ;;
        "7z")
            7z a "$output_file" @"$file_list" > /dev/null 2>&1
            ;;
    esac
    
    # Limpiar lista temporal
    rm -f "$file_list"
    
    if [ -f "$output_file" ]; then
        original_size=0
        for file in "${SELECTED_FILES[@]}"; do
            [ -f "$file" ] && original_size=$((original_size + $(du -k "$file" | cut -f1)))
        done
        
        compressed_size=$(du -k "$output_file" | cut -f1)
        ratio=$(( (compressed_size * 100) / (original_size > 0 ? original_size : 1) ))
        
       rm -rf "$file_list" 2>/dev/null
	_Logo
        echo -e "$G ¡COMPRESIÓN EXITOSA!$RE"
        echo -e "$Y Archivo creado: $Y$archive_name$RE"
        echo -e "$Y Tamaño original: $((original_size / 1024)) MB$RE"
        echo -e "$Y Tamaño comprimido: $((compressed_size / 1024)) MB$RE"
        echo -e "$Y Ratio de compresión: ${ratio}%$RE"
        echo -e "$Y Ubicación: $original_path$RE"
    else
        echo -e $R"Error en la compresión$RE"
    fi
    
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _FindEmptyDirs() {
    _Logo
    echo -e "$G BUSCAR Y ELIMINAR CARPETAS VACÍAS$RE"
    echo -e "$Y Ingresa la ruta a analizar:$RE"
    echo -e "$C (Deja vacío para escanear todo el almacenamiento)$RE"
    read -p " >> " scan_path
    
    if [ -z "$scan_path" ]; then
        scan_path="/"
    elif [ ! -d "$scan_path" ]; then
        echo -e $R"La ruta no existe$RE"
        sleep 2
        return
    fi

    # Excluir directorios del sistema importantes
    exclude_dirs=("/proc" "/sys" "/dev" "/acct" "/config" "/mnt" "/tmp" "/data/data/com.termux/files/usr/tmp")
    exclude_opts=""
    for dir in "${exclude_dirs[@]}"; do
        exclude_opts+=" -path $dir -prune -o"
    done

    _Logo
    echo -e "$Y Escaneando $scan_path en busca de carpetas vacías...$RE"
    echo -e "$C Esto puede tomar tiempo dependiendo del tamaño del almacenamiento$RE"
    
    # Encontrar todas las carpetas vacías
    empty_dirs=()
    while IFS= read -r -d $'\0' dir; do
        empty_dirs+=("$dir")
        echo -ne ".\c"
    done < <(find "$scan_path" $exclude_opts -type d -empty -print0 2>/dev/null)
    
    _Logo
    if [ ${#empty_dirs[@]} -eq 0 ]; then
        echo -e "$G ¡No se encontraron carpetas vacías!$RE"
        read -n 1 -p "Presiona ENTER para continuar..."
        return
    fi
    
    echo -e "$Y Se encontraron ${#empty_dirs[@]} carpetas vacías:$RE"
    echo -e "$G Mostrando las primeras 10:$RE"
    for ((i=0; i<10 && i<${#empty_dirs[@]}; i++)); do
        echo -e " - $C${empty_dirs[i]}$RE"
    done
    
    if [ ${#empty_dirs[@]} -gt 10 ]; then
        echo -e "$Y ... y $(( ${#empty_dirs[@]} - 10 )) más$RE"
    fi
    
    echo -e "$G"
    read -p "¿Deseas eliminar todas las carpetas vacías? (s/n): " delete_choice
    echo -e "$RE"
    
    if [[ "$delete_choice" =~ [sS] ]]; then
        deleted_count=0
        _Logo
        echo -e "$Y Eliminando carpetas vacías...$RE"
        
        for dir in "${empty_dirs[@]}"; do
            # Verificar que todavía está vacía antes de eliminar
            if [ -d "$dir" ] && [ -z "$(ls -A "$dir")" ]; then
                rmdir "$dir" 2>/dev/null
                if [ $? -eq 0 ]; then
                    echo -e " - $G$dir$RE"
                    deleted_count=$((deleted_count + 1))
                else
                    echo -e " - $R$dir (falló)$RE"
                fi
            fi
        done
        
        _Logo
        echo -e "$G ELIMINACIÓN COMPLETADA!$RE"
        echo -e "$Y Carpetas eliminadas: $deleted_count/${#empty_dirs[@]}$RE"
    else
        echo -e "$Y Conservando las carpetas.$RE"
    fi
    
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _ClearCache() {
    _Logo
    echo -e "$G LIMPIANDO CACHÉ DE LA APLICACIÓN$RE"
    
    cache_dirs=(
        "/data/data/com.termux/files/usr/tmp"
        "/data/data/com.termux/cache"
        "$HOME/.cache"
        "/sdcard/Android/data/com.termux/files/tmp"
    )
    
    total_freed=0
    for dir in "${cache_dirs[@]}"; do
        if [ -d "$dir" ]; then
            size_before=$(du -s "$dir" | cut -f1)
            rm -rf "${dir:?}/"*
            size_after=$(du -s "$dir" | cut -f1)
            freed=$((size_before - size_after))
            total_freed=$((total_freed + freed))
            echo -e "$Y - $dir: ${freed}KB liberados$RE"
        fi
    done
    
    echo -e "$G TOTAL: $((total_freed / 1024)) MB liberados$RE"
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _AdvancedMode() {
    while true; do
        _Logo
        echo -e "$G MODO AVANZADO - HERRAMIENTAS PROFESIONALES$RE"
        echo -e "$Y Selecciona una opción:$G"
        echo -e "[$RE 1$G ]$Y Editor de parámetros FFmpeg$G"
        echo -e "[$RE 2$G ]$Y Editor de parámetros ImageMagick$G"
        echo -e "[$RE 3$G ]$Y Scripting avanzado$G"
        echo -e "[$RE 4$G ]$Y Monitor de recursos en tiempo real$G"
        echo -e "[$RE 5$G ]$Y Gestión de proyectos multimedia$G"
        echo -e "[$RE 6$G ]$Y Herramientas de diagnóstico$G"
        echo -e "[$RE 7$G ]$Y Modo consola profesional$G"
        echo -e "[$RE 0$G ]$Y Volver al menú principal$RE"
        
        read -p " >> " advanced_opt
        
        case $advanced_opt in
            1) _FFmpegAdvancedEditor ;;
            2) _ImageMagickAdvancedEditor ;;
            3) _AdvancedScripting ;;
            4) _ResourceMonitor ;;
            5) _ProjectManager ;;
            6) _DiagnosticTools ;;
            7) _ProConsole ;;
            0) _Menu ;;
            *) echo -e $R"Opción inválida$RE"; sleep 1 ;;
        esac
    done
}

function _FFmpegAdvancedEditor() {
    _Logo
    echo -e "$G EDITOR AVANZADO DE FFMPEG$RE"
    echo -e "$Y Selecciona una categoría:$G"
    echo -e "[$RE 1$G ]$Y Códecs de video$G"
    echo -e "[$RE 2$G ]$Y Códecs de audio$G"
    echo -e "[$RE 3$G ]$Y Filtros complejos$G"
    echo -e "[$RE 4$G ]$Y Configuración de hardware$G"
    echo -e "[$RE 5$G ]$Y Edición de metadatos$G"
    echo -e "[$RE 6$G ]$Y Comando personalizado$G"
    echo -e "[$RE 0$G ]$Y Volver$RE"
    
    read -p " >> " ffmpeg_cat
    
    case $ffmpeg_cat in
        1) _VideoCodecsEditor ;;
        2) _AudioCodecsEditor ;;
        3) _ComplexFiltersEditor ;;
        4) _HardwareConfigEditor ;;
        5) _MetadataEditor ;;
        6) _CustomFFmpegCommand ;;
        0) _AdvancedMode ;;
        *) echo -e $R"Opción inválida$RE"; sleep 1; _FFmpegAdvancedEditor ;;
    esac
}

function _VideoCodecsEditor() {
    _Logo
    echo -e "$G CONFIGURADOR DE CÓDECS DE VIDEO$RE"
    
    # Obtener códecs disponibles
    codecs=$(ffmpeg -codecs 2>/dev/null | grep '^ .EV' | awk '{print $2}' | sort)
    
    echo -e "$Y Códecs de video disponibles:$RE"
    i=1
    declare -A codec_map
    for codec in $codecs; do
        echo -e "$i) $codec"
        codec_map[$i]=$codec
        ((i++))
    done
    
    read -p "Selecciona un códec: " codec_sel
    
    selected_codec=${codec_map[$codec_sel]}
    
    if [ -z "$selected_codec" ]; then
        echo -e $R"Selección inválida$RE"
        sleep 1
        return
    fi
    
    _Logo
    echo -e "$G CONFIGURANDO $selected_codec$RE"
    
    # Parámetros comunes
    echo -e "$Y Bitrate (ej: 2M, 500k):$RE"
    read -p " >> " bitrate
    
    echo -e "$Y Velocidad de codificación (0-ultrafast 12-veryslow):$RE"
    read -p " >> " preset
    
    echo -e "$Y Perfil (baseline, main, high):$RE"
    read -p " >> " profile
    
    # Crear comando base
    cmd="-c:v $selected_codec"
    [ -n "$bitrate" ] && cmd+=" -b:v $bitrate"
    [ -n "$preset" ] && cmd+=" -preset $preset"
    [ -n "$profile" ] && cmd+=" -profile:v $profile"
    
    _Logo
    echo -e "$G COMANDO GENERADO:$RE"
    echo -e "$C$cmd$RE"
    
    echo -e "$G ¿Deseas aplicar este códec a una conversión ahora? (s/n)$RE"
    read -p " >> " apply
    
    if [[ "$apply" =~ [sS] ]]; then
        _ApplyFFmpegCommand "$cmd"
    else
        echo -e "$Y Comando copiado al portapapeles$RE"
        echo "$cmd" | termux-clipboard-set
        sleep 2
    fi
}

function _ApplyFFmpegCommand() {
    local cmd=$1
    
    _Logo
    echo -e "$G APLICAR CONFIGURACIÓN AVANZADA$RE"
    echo -e "$Y Ingresa el archivo de entrada:$RE"
    read -p " >> " input_file
    
    if [ ! -f "$input_file" ]; then
        echo -e $R"Archivo no encontrado$RE"
        sleep 2
        return
    fi
    
    echo -e "$Y Ingresa el archivo de salida:$RE"
    read -p " >> " output_file
    
    _Logo
    echo -e "$Y Ejecutando comando...$RE"
    echo -e "$C ffmpeg -i \"$input_file\" $cmd \"$output_file\"$RE"
    
    ffmpeg -i "$input_file" $cmd "$output_file"
    
    if [ $? -eq 0 ]; then
        echo -e "$G Conversión exitosa!$RE"
        echo -e "$Y Archivo creado: $output_file$RE"
    else
        echo -e $R"Error en la conversión$RE"
    fi
    
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _AdvancedScripting() {
    _Logo
    echo -e "$G SCRIPTING AVANZADO$RE"
    echo -e "$Y Selecciona una opción:$G"
    echo -e "[$RE 1$G ]$Y Crear nuevo script$G"
    echo -e "[$RE 2$G ]$Y Editar script existente$G"
    echo -e "[$RE 3$G ]$Y Ejecutar script$G"
    echo -e "[$RE 4$G ]$Y Programar tareas$G"
    echo -e "[$RE 5$G ]$Y Biblioteca de scripts$G"
    echo -e "[$RE 0$G ]$Y Volver$RE"
    
    read -p " >> " script_opt
    
    case $script_opt in
        1) _CreateScript ;;
        2) _EditScript ;;
        3) _RunScript ;;
        4) _ScheduleTasks ;;
        5) _ScriptLibrary ;;
        0) _AdvancedMode ;;
        *) echo -e $R"Opción inválida$RE"; sleep 1; _AdvancedScripting ;;
    esac
}

function _CreateScript() {
    _Logo
    echo -e "$G CREAR NUEVO SCRIPT$RE"
    echo -e "$Y Ingresa nombre para el script:$RE"
    read -p " >> " script_name
    
    # Crear directorio si no existe
    mkdir -p ~/.milux/scripts
    
    script_path=~/.milux/scripts/"$script_name.sh"
    
    if [ -f "$script_path" ]; then
        echo -e $R"Ya existe un script con ese nombre$RE"
        sleep 2
        return
    fi
    
    # Plantilla básica
    cat > "$script_path" <<EOL
#!/data/data/com.termux/files/usr/bin/bash

# Script creado con Converter Advanced Mode
# Fecha: $(date)

# Configuración
INPUT_DIR=""
OUTPUT_DIR=""
LOG_FILE="\${OUTPUT_DIR}/procesamiento.log"

# Función para procesar archivos
process_file() {
    local file="\$1"
    local output="\${OUTPUT_DIR}/\$(basename "\$file")"
    
    # Ejemplo: convertir a MP4 con H.265
    ffmpeg -i "\$file" -c:v libx265 -c:a aac "\$output"
    
    echo "Procesado: \$file -> \$output" >> "\$LOG_FILE"
}

# Procesamiento principal
echo "Iniciando procesamiento: \$(date)" > "\$LOG_FILE"
for file in "\${INPUT_DIR}"/*; do
    if [ -f "\$file" ]; then
        process_file "\$file"
    fi
done
echo "Procesamiento completado: \$(date)" >> "\$LOG_FILE"
EOL

    chmod +x "$script_path"
    
    echo -e "$G Script creado en: $script_path$RE"
    echo -e "$Y ¿Deseas editarlo ahora? (s/n)$RE"
    read -p " >> " edit_now
    
    if [[ "$edit_now" =~ [sS] ]]; then
        vim "$script_path"
    fi
    
    sleep 2
}

# Función para crear un nuevo script
function _CreateScript() {
    _Logo
    echo -e "$G CREAR NUEVO SCRIPT$RE"
    read -p "Nombre del script (sin extensión .sh): " script_name
    
    # Verificar si el script ya existe
    if [ -f "scripts/${script_name}.sh" ]; then
        echo -e "$R El script '${script_name}.sh' ya existe.$RE"
        read -p "¿Deseas sobrescribirlo? (s/n): " overwrite
        if [[ "$overwrite" != "s" && "$overwrite" != "S" ]]; then
            _AdvancedScripting
            return
        fi
    fi
    
    # Crear directorio scripts si no existe
    mkdir -p scripts
    
    # Crear el script con contenido básico
    echo "#!/bin/bash" > "scripts/${script_name}.sh"
    echo -e "\n# Descripción: " >> "scripts/${script_name}.sh"
    echo -e "# Autor: $(whoami)" >> "scripts/${script_name}.sh"
    echo -e "# Fecha: $(date +%Y-%m-%d)" >> "scripts/${script_name}.sh"
    echo -e "\n# Configuración de colores" >> "scripts/${script_name}.sh"
    echo 'RE="\e[0m"' >> "scripts/${script_name}.sh"
    echo 'R="\e[31m"' >> "scripts/${script_name}.sh"
    echo 'G="\e[32m"' >> "scripts/${script_name}.sh"
    echo 'Y="\e[33m"' >> "scripts/${script_name}.sh"
    echo -e "\n# Tu código aquí\n" >> "scripts/${script_name}.sh"
    
    chmod +x "scripts/${script_name}.sh"
    echo -e "$G Script '${script_name}.sh' creado con éxito.$RE"
    
    read -p "¿Deseas editarlo ahora? (s/n): " edit_now
    if [[ "$edit_now" == "s" || "$edit_now" == "S" ]]; then
        _EditScript "$script_name"
    else
        _AdvancedScripting
    fi
}

# Función para editar un script existente
function _EditScript() {
    _Logo
    echo -e "$G EDITAR SCRIPT$RE"
    
    local script_name=$1
    
    if [ -z "$script_name" ]; then
        echo -e "Scripts disponibles en el directorio scripts/:"
        ls scripts/*.sh 2>/dev/null | sed 's|scripts/||g'
        echo ""
        read -p "Nombre del script a editar (sin extensión .sh): " script_name
    fi
    
    if [ ! -f "scripts/${script_name}.sh" ]; then
        echo -e "$R El script '${script_name}.sh' no existe.$RE"
        sleep 1
        _AdvancedScripting
        return
    fi
    
    # Usar el editor preferido (nano por defecto)
    ${EDITOR:-nano} "scripts/${script_name}.sh"
    
    echo -e "$G Script '${script_name}.sh' editado.$RE"
    sleep 1
    _AdvancedScripting
}

# Función para ejecutar un script
function _RunScript() {
    _Logo
    echo -e "$G EJECUTAR SCRIPT$RE"
    
    echo -e "Scripts disponibles en el directorio scripts/:"
    ls scripts/*.sh 2>/dev/null | sed 's|scripts/||g'
    echo ""
    read -p "Nombre del script a ejecutar (sin extensión .sh): " script_name
    
    if [ ! -f "scripts/${script_name}.sh" ]; then
        echo -e "$R El script '${script_name}.sh' no existe.$RE"
        sleep 1
        _AdvancedScripting
        return
    fi
    
    # Dar permisos de ejecución por si acaso
    chmod +x "scripts/${script_name}.sh"
    
    echo -e "$Y Ejecutando script...$RE"
    echo -e "----------------------------------------"
    ./scripts/"${script_name}.sh"
    echo -e "----------------------------------------"
    
    read -p "Presiona Enter para continuar..."
    _AdvancedScripting
}

# Función para programar tareas con crontab
function _ScheduleTasks() {
    _Logo
    echo -e "$G PROGRAMAR TAREAS$RE"
    echo -e "$Y Selecciona una opción:$G"
    echo -e "[$RE 1$G ]$Y Ver tareas programadas$G"
    echo -e "[$RE 2$G ]$Y Agregar nueva tarea$G"
    echo -e "[$RE 3$G ]$Y Editar tareas$G"
    echo -e "[$RE 4$G ]$Y Eliminar tarea$G"
    echo -e "[$RE 0$G ]$Y Volver$RE"
    
    read -p " >> " cron_opt
    
    case $cron_opt in
        1) crontab -l; read -p "Presiona Enter para continuar..." ;;
        2) _AddCronTask ;;
        3) crontab -e ;;
        4) _RemoveCronTask ;;
        0) _AdvancedScripting ;;
        *) echo -e $R"Opción inválida$RE"; sleep 1; _ScheduleTasks ;;
    esac
    
    _ScheduleTasks
}

# Función auxiliar para agregar tareas cron
function _AddCronTask() {
    echo -e "$G AGREGAR NUEVA TAREA$RE"
    echo -e "Formatos:"
    echo -e "Minuto (0-59), Hora (0-23), Día del mes (1-31), Mes (1-12), Día de la semana (0-6, 0=Domingo)"
    echo -e "Ejemplos:"
    echo -e "* * * * *  - Cada minuto"
    echo -e "0 * * * *  - Cada hora"
    echo -e "0 0 * * *  - Cada día a medianoche"
    echo -e "0 0 * * 0  - Cada domingo a medianoche"
    
    read -p "Programación (ej. '0 0 * * *'): " cron_schedule
    read -p "Comando o script a ejecutar (ruta completa): " cron_command
    
    # Agregar la tarea al crontab del usuario actual
    (crontab -l 2>/dev/null; echo "$cron_schedule $cron_command") | crontab -
    
    echo -e "$G Tarea agregada:$RE"
    echo -e "$cron_schedule $cron_command"
    sleep 2
}

# Función auxiliar para eliminar tareas cron
function _RemoveCronTask() {
    echo -e "$G ELIMINAR TAREA$RE"
    crontab -l
    echo ""
    read -p "Introduce el número de línea de la tarea a eliminar: " cron_line
    
    crontab -l | sed -e "${cron_line}d" | crontab -
    
    echo -e "$G Tarea eliminada.$RE"
    sleep 1
}

# Función para la biblioteca de scripts
function _ScriptLibrary() {
    _Logo
    echo -e "$G BIBLIOTECA DE SCRIPTS$RE"
    echo -e "$Y Selecciona una opción:$G"
    echo -e "[$RE 1$G ]$Y Scripts de conversión multimedia$G"
    echo -e "[$RE 2$G ]$Y Scripts de red$G"
    echo -e "[$RE 3$G ]$Y Scripts de sistema$G"
    echo -e "[$RE 4$G ]$Y Scripts de respaldo$G"
    echo -e "[$RE 0$G ]$Y Volver$RE"
    
    read -p " >> " lib_opt
    
    case $lib_opt in
        1) _ShowMediaScripts ;;
        2) _ShowNetworkScripts ;;
        3) _ShowSystemScripts ;;
        4) _ShowBackupScripts ;;
        0) _AdvancedScripting ;;
        *) echo -e $R"Opción inválida$RE"; sleep 1; _ScriptLibrary ;;
    esac
}

# Funciones auxiliares para la biblioteca de scripts
function _ShowMediaScripts() {
    echo -e "$G SCRIPTS DE CONVERSIÓN MULTIMEDIA$RE"
    echo -e "Estos scripts utilizan ffmpeg para diversas conversiones:"
    echo -e "[$RE 1$G ]$Y Convertir video a diferentes formatos$G"
    echo -e "[$RE 2$G ]$Y Extraer audio de un video$G"
    echo -e "[$RE 3$G ]$Y Reducir tamaño de video$G"
    echo -e "[$RE 4$G ]$Y Convertir imágenes a video$G"
    echo -e "[$RE 0$G ]$Y Volver$RE"
    
    read -p " >> " media_opt
    
    case $media_opt in
        0) _ScriptLibrary ;;
        *) echo -e "$Y Descargando script...$RE"; sleep 1; echo -e "$G Script disponible en scripts/ $RE"; _ScriptLibrary ;;
    esac
}

function _ShowNetworkScripts() {
    echo -e "$G SCRIPTS DE RED$RE"
    echo -e "[$RE 1$G ]$Y Analizar puertos abiertos$G"
    echo -e "[$RE 2$G ]$Y Monitorizar ancho de banda$G"
    echo -e "[$RE 3$G ]$Y Conectar a VPN$G"
    echo -e "[$RE 0$G ]$Y Volver$RE"
    
    read -p " >> " net_opt
    
    case $net_opt in
        0) _ScriptLibrary ;;
        *) echo -e "$Y Descargando script...$RE"; sleep 1; echo -e "$G Script disponible en scripts/ $RE"; _ScriptLibrary ;;
    esac
}

function _ShowSystemScripts() {
    echo -e "$G SCRIPTS DE SISTEMA$RE"
    echo -e "[$RE 1$G ]$Y Limpiar espacio en disco$G"
    echo -e "[$RE 2$G ]$Y Monitorizar recursos$G"
    echo -e "[$RE 3$G ]$Y Actualizar sistema$G"
    echo -e "[$RE 0$G ]$Y Volver$RE"
    
    read -p " >> " sys_opt
    
    case $sys_opt in
        0) _ScriptLibrary ;;
        *) echo -e "$Y Descargando script...$RE"; sleep 1; echo -e "$G Script disponible en scripts/ $RE"; _ScriptLibrary ;;
    esac
}

function ShowBackupScripts() {
    echo -e "$G SCRIPTS DE RESPALDO$RE"
    echo -e "[$RE 1$G ]$Y Respaldar directorio$G"
    echo -e "[$RE 2$G ]$Y Restaurar respaldo$G"
    echo -e "[$RE 3$G ]$Y Sincronizar con servidor remoto$G"
    echo -e "[$RE 0$G ]$Y Volver$RE"
    
    read -p " >> " backup_opt
    
    case $backup_opt in
        0) _ScriptLibrary ;;
        *) echo -e "$Y Descargando script...$RE"; sleep 1; echo -e "$G Script disponible en scripts/ $RE"; _ScriptLibrary ;;
    esac
}

function _ResourceMonitor() {
    _Logo
    echo -e "$G MONITOR DE RECURSOS$RE"
    echo -e "$Y Monitoreando recursos (Ctrl+C para salir)...$RE"
    
    # Configurar para capturar Ctrl+C
    trap "return" SIGINT
    
    while true; do
        clear
        _Logo
        echo -e "$G MONITOR DE RECURSOS - TIEMPO REAL$RE"
        
        # CPU
        cpu_usage=$(top -bn1 | grep "CPU:" | awk '{print $2}')
        echo -e "$Y CPU: $cpu_usage% usado$RE"
        
        # Memoria
        mem_total=$(free -m | awk 'NR==2{print $2}')
        mem_used=$(free -m | awk 'NR==2{print $3}')
        mem_percent=$((mem_used * 100 / mem_total))
        echo -e "$Y Memoria: ${mem_used}MB/${mem_total}MB ($mem_percent%)$RE"
        
        # Almacenamiento
        storage_total=$(df -h /data | awk 'NR==2{print $2}')
        storage_used=$(df -h /data | awk 'NR==2{print $3}')
        storage_percent=$(df -h /data | awk 'NR==2{print $5}')
        echo -e "$Y Almacenamiento: $storage_used/$storage_total ($storage_percent)$RE"
        
        # Temperatura (si está disponible)
        if [ -f "/sys/class/thermal/thermal_zone0/temp" ]; then
            temp=$(cat /sys/class/thermal/thermal_zone0/temp)
            temp_c=$((temp/1000))
            echo -e "$Y Temperatura CPU: ${temp_c}°C$RE"
        fi
        
        # Procesos de FFmpeg/ImageMagick
        echo -e "$Y Procesos activos:$RE"
        ps aux | grep -E 'ffmpeg|mogrify|convert' | grep -v grep
        
        # Esperar 2 segundos
        sleep 2
    done
}

function _ProjectManager() {
    while true; do  # Bucle infinito hasta que elija volver
        _Logo
        echo -e "$G GESTOR DE PROYECTOS$RE"
        echo -e "$Y Selecciona una opción:$G"
        echo -e "[$RE 1$G ]$Y Crear nuevo proyecto$G"
        echo -e "[$RE 2$G ]$Y Abrir proyecto existente$G"
        
        # Solo mostrar estas opciones si hay un proyecto abierto
        if [ -n "$CURRENT_PROJECT" ]; then
            echo -e "[$RE 3$G ]$Y Configurar pipeline$G"
            echo -e "[$RE 4$G ]$Y Renderizar proyecto$G"
            echo -e "[$RE 5$G ]$Y Exportar proyecto$G"
            echo -e "[$RE 6$G ]$Y Ver información del proyecto$G"
        fi
        
        echo -e "[$RE 0$G ]$Y Volver$RE"
        
        read -p " >> " project_opt
        
        case $project_opt in
            1) _CreateProject ;;
            2) _OpenProject ;;
            3) [ -n "$CURRENT_PROJECT" ] && _SetupPipeline || echo -e "$R Abre un proyecto primero$RE"; sleep 1 ;;
            4) [ -n "$CURRENT_PROJECT" ] && _RenderProject || echo -e "$R Abre un proyecto primero$RE"; sleep 1 ;;
            5) [ -n "$CURRENT_PROJECT" ] && _ExportProject || echo -e "$R Abre un proyecto primero$RE"; sleep 1 ;;
            6) [ -n "$CURRENT_PROJECT" ] && _ShowProjectInfo || echo -e "$R Abre un proyecto primero$RE"; sleep 1 ;;
            0) break ;;  # Salir del bucle while
            *) echo -e $R"Opción inválida$RE"; sleep 1 ;;
        esac
    done
}

function _CreateProject() {
    _Logo
    echo -e "$G CREAR NUEVO PROYECTO$RE"
    echo -e "$Y Ingresa nombre para el proyecto:$RE"
    read -p " >> " project_name
    
    # Validar nombre
    if [[ -z "$project_name" ]]; then
        echo -e "$R El nombre no puede estar vacío$RE"
        sleep 1
        return 1
    fi

    project_dir="$PROJECTS_DIR/$project_name"
    
    if [ -d "$project_dir" ]; then
        echo -e "$R Ya existe un proyecto con ese nombre$RE"
        sleep 1
        return 1
    fi
    
    # Crear estructura
    mkdir -p "$project_dir"/{assets,exports,scripts,logs}
    
    # Configuración por defecto
    cat > "$project_dir/$PROJECT_CONFIG" <<EOL
# Configuración de proyecto: $project_name
# Creado: $(date +"%Y-%m-%d %H:%M:%S")

[video]
codec=libx264
resolution=1920x1080
bitrate=5M
framerate=30

[audio]
codec=aac
bitrate=192k
sample_rate=44100

[image]
quality=90
resize=100%
EOL

    echo -e "$G Proyecto creado en:$RE"
    echo -e "$Y $project_dir $RE"
    echo -e "\n$Y Directorios creados:$RE"
    echo -e "- assets/: Para archivos fuente"
    echo -e "- exports/: Para resultados"
    echo -e "- scripts/: Para scripts personalizados"
    echo -e "- logs/: Para registros de procesamiento"
    
    CURRENT_PROJECT="$project_dir"
    _SendNotification "Nuevo Proyecto" "Proyecto '$project_name' creado"
    sleep 2
}

function _OpenProject() {
    while true; do
        _Logo
        echo -e "$Y PROYECTOS DISPONIBLES:$RE"
        local projects=()
        local i=0

        # Buscar proyectos válidos
        while IFS= read -r -d $'\0' dir; do
            projects+=("$dir")
            echo -e "[$RE $i $G] $Y $(basename "$dir") $RE"
            ((i++))
        done < <(find "$PROJECTS_DIR" -mindepth 1 -maxdepth 1 -type d -exec test -f "{}/$PROJECT_CONFIG" \; -print0 2>/dev/null)

        echo -e "$G\n[$RE b$G ]$Y Volver$RE"

        if [ $i -eq 0 ]; then
            echo -e "$R No se encontraron proyectos $RE"
            sleep 2
            return 1
        fi

        read -p "Selecciona proyecto >> " choice

        if [[ "$choice" == "b" ]]; then
            return 1
        elif [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -lt "$i" ]; then
            CURRENT_PROJECT="${projects[$choice]}"
            echo -e "$G Proyecto abierto: $Y$(basename "$CURRENT_PROJECT")$RE"
            return 0
        else
            echo -e "$R Opción inválida$RE"
            sleep 1
        fi
    done
}

function _SetupPipeline() {
    [ -z "$CURRENT_PROJECT" ] && { echo -e "$R Abre un proyecto primero$RE"; sleep 1; return 1; }

    _Logo
    echo -e "$G CONFIGURAR PIPELINE$RE"
    echo -e "$Y Proyecto actual: $C$(basename "$CURRENT_PROJECT")$RE"
    echo -e "$Y Selecciona qué configurar:$G"
    echo -e "[$RE 1$G ]$Y Video$G"
    echo -e "[$RE 2$G ]$Y Audio$G"
    echo -e "[$RE 3$G ]$Y Imágenes$G"
    echo -e "[$RE 4$G ]$Y Mostrar configuración actual$G"
    echo -e "[$RE 0$G ]$Y Volver$RE"

    read -p " >> " config_opt

    case $config_opt in
        1)
            _Logo
            echo -e "$G CONFIGURACIÓN DE VIDEO$RE"
            echo -e "$Y Valores actuales:$RE"
            grep -A4 "^\[video\]" "$CURRENT_PROJECT/$PROJECT_CONFIG"

            read -p "Codec (ej: libx264, libx265): " vcodec
            read -p "Resolución (ej: 1280x720): " resolution
            read -p "Bitrate (ej: 2.5M): " bitrate
            read -p "Framerate (ej: 24, 30, 60): " framerate

            # Actualizar configuración
            sed -i "/^\[video\]/,/^\[/ {
                s/^codec=.*/codec=$vcodec/
                s/^resolution=.*/resolution=$resolution/
                s/^bitrate=.*/bitrate=$bitrate/
                s/^framerate=.*/framerate=$framerate/
            }" "$CURRENT_PROJECT/$PROJECT_CONFIG"

            echo -e "$G Configuración de video actualizada$RE"
            ;;
        2)
            _Logo
            echo -e "$G CONFIGURACIÓN DE AUDIO$RE"
            echo -e "$Y Valores actuales:$RE"
            grep -A3 "^\[audio\]" "$CURRENT_PROJECT/$PROJECT_CONFIG"

            read -p "Codec (ej: aac, libmp3lame): " acodec
            read -p "Bitrate (ej: 128k, 192k): " bitrate
            read -p "Sample rate (ej: 44100, 48000): " sample_rate

            sed -i "/^\[audio\]/,/^\[/ {
                s/^codec=.*/codec=$acodec/
                s/^bitrate=.*/bitrate=$bitrate/
                s/^sample_rate=.*/sample_rate=$sample_rate/
            }" "$CURRENT_PROJECT/$PROJECT_CONFIG"

            echo -e "$G Configuración de audio actualizada$RE"
            ;;
        3)
            _Logo
            echo -e "$G CONFIGURACIÓN DE IMÁGENES$RE"
            echo -e "$Y Valores actuales:$RE"
            grep -A2 "^\[image\]" "$CURRENT_PROJECT/$PROJECT_CONFIG"

            read -p "Calidad (1-100): " quality
            read -p "Redimensionar (ej: 50%, 800x600): " resize

            sed -i "/^\[image\]/,/^\[/ {
                s/^quality=.*/quality=$quality/
                s/^resize=.*/resize=$resize/
            }" "$CURRENT_PROJECT/$PROJECT_CONFIG"

            echo -e "$G Configuración de imágenes actualizada$RE"
            ;;
        4)
            _ShowProjectInfo
            return
            ;;
        0)
            return
            ;;
        *)
            echo -e "$R Opción inválida$RE"
            ;;
    esac

    sleep 1
}

function _RenderProject() {
    [ -z "$CURRENT_PROJECT" ] && { echo -e "$R Abre un proyecto primero$RE"; sleep 1; return 1; }

    _Logo
    echo -e "$G RENDERIZAR PROYECTO$RE"
    echo -e "$Y Proyecto: $C$(basename "$CURRENT_PROJECT")$RE"

    # Verificar assets
    if [ ! -d "$CURRENT_PROJECT/assets" ] || [ -z "$(ls -A "$CURRENT_PROJECT/assets")" ]; then
        echo -e "$R No hay archivos en la carpeta assets/$RE"
        sleep 2
        return 1
    fi

    # Cargar configuración
    source <(grep = <(grep -A5 "^\[video\]" "$CURRENT_PROJECT/$PROJECT_CONFIG") | sed 's/ /=/')
    source <(grep = <(grep -A4 "^\[audio\]" "$CURRENT_PROJECT/$PROJECT_CONFIG") | sed 's/ /=/')
    source <(grep = <(grep -A3 "^\[image\]" "$CURRENT_PROJECT/$PROJECT_CONFIG") | sed 's/ /=/')

    # Procesar archivos
    processed=0
    for file in "$CURRENT_PROJECT/assets"/*; do
        filename=$(basename "$file")
        extension="${filename##*.}"
        output_file="$CURRENT_PROJECT/exports/${filename%.*}_converted"

        _Logo
        echo -e "$Y Procesando: $G$filename$RE"
        echo -e "$Y Tipo detectado: $extension$RE"

        case $extension in
            mp4|avi|mov|mkv|flv)
                output_file+=".mp4"
                ffmpeg -i "$file" \
                    -c:v $codec -vf "scale=$resolution" -b:v $bitrate -r $framerate \
                    -c:a $acodec -b:a $bitrate -ar $sample_rate \
                    "$output_file" > "$CURRENT_PROJECT/logs/ffmpeg.log" 2>&1
                ;;
            mp3|wav|ogg|flac)
                output_file+=".mp3"
                ffmpeg -i "$file" \
                    -c:a $acodec -b:a $bitrate -ar $sample_rate \
                    "$output_file" > "$CURRENT_PROJECT/logs/ffmpeg.log" 2>&1
                ;;
            jpg|jpeg|png|gif|bmp)
                output_file+=".jpg"
                convert "$file" -quality $quality -resize $resize "$output_file" > "$CURRENT_PROJECT/logs/convert.log" 2>&1
                ;;
            *)
                echo -e "$R Formato no soportado: $extension$RE"
                continue
                ;;
        esac

        if [ -f "$output_file" ]; then
            echo -e "$G ✓ Convertido a: $(basename "$output_file")$RE"
            ((processed++))
        else
            echo -e "$R ✗ Error al procesar $filename$RE"
        fi
        sleep 1
    done

    _SendNotification "Render Completado" "Procesados $processed archivos"
    echo -e "\n$G Proceso finalizado. Archivos en exports/$RE"
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _ExportProject() {
    [ -z "$CURRENT_PROJECT" ] && { echo -e "$R Abre un proyecto primero$RE"; sleep 1; return 1; }

    _Logo
    echo -e "$G EXPORTAR PROYECTO$RE"
    echo -e "$Y Proyecto: $C$(basename "$CURRENT_PROJECT")$RE"

    # Verificar exports
    if [ ! -d "$CURRENT_PROJECT/exports" ] || [ -z "$(ls -A "$CURRENT_PROJECT/exports")" ]; then
        echo -e "$R No hay archivos en la carpeta exports/$RE"
        sleep 2
        return 1
    fi

    # Crear nombre de archivo
    export_name="$(basename "$CURRENT_PROJECT")_$(date +"%Y%m%d_%H%M").zip"
    export_path="/sdcard/Download/$export_name"

    # Comprimir
    echo -e "$Y Comprimiendo archivos...$RE"
    cd "$CURRENT_PROJECT/exports" || return 1
    zip -r "$export_path" ./* > "$CURRENT_PROJECT/logs/export.log" 2>&1

    if [ -f "$export_path" ]; then
        _Logo
        echo -e "$G ✓ Exportación completada$RE"
        echo -e "$Y Archivo ZIP creado en:$RE"
        echo -e "$C $export_path $RE"
        echo -e "$Y Tamaño: $(du -h "$export_path" | cut -f1)$RE"

        _SendNotification "Exportación Exitosa" "Proyecto exportado a $export_name"
    else
        echo -e "$R Error al crear archivo ZIP$RE"
        echo -e "$Y Ver logs/export.log para detalles$RE"
    fi

    cd - >/dev/null || return 1
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _ShowProjectInfo() {
    _Logo
    echo -e "$G INFORMACIÓN DEL PROYECTO$RE"
    echo -e "Nombre: $Y$(basename "$CURRENT_PROJECT")$RE"
    echo -e "Ruta: $C$CURRENT_PROJECT$RE"

    if [ -f "$CURRENT_PROJECT/$PROJECT_CONFIG" ]; then
        echo -e "\n$Y CONFIGURACIÓN ACTUAL:$RE"
        grep -v '^#' "$CURRENT_PROJECT/$PROJECT_CONFIG" | while read -r line; do
            echo -e " - $G${line%%=*}$RE: $Y${line#*=}$RE"
        done
    else
        echo -e "$R No se encontró archivo de configuración$RE"
    fi

    echo -e "\n$Y CONTENIDO DEL PROYECTO:$RE"
    echo -e "Assets: $(ls "$CURRENT_PROJECT/assets" | wc -l) archivos"
    echo -e "Exports: $(ls "$CURRENT_PROJECT/exports" | wc -l) archivos"

    read -n 1 -p "Presiona ENTER para continuar..."
}

function _DiagnosticTools() {
    while true; do
        _Logo
        echo -e "$G HERRAMIENTAS DE DIAGNÓSTICO AVANZADO$RE"
        echo -e "$Y Selecciona una herramienta:$G"
        echo -e "[$RE 1$G ]$Y Verificar integridad de archivos multimedia$G"
        echo -e "[$RE 2$G ]$Y Analizar calidad de video (PSNR/SSIM)$G"
        echo -e "[$RE 3$G ]$Y Generar espectrograma de audio$G"
        echo -e "[$RE 4$G ]$Y Informe técnico completo$G"
        echo -e "[$RE 5$G ]$Y Comparación entre dos archivos$G"
        echo -e "[$RE 6$G ]$Y Benchmark de rendimiento$G"
        echo -e "[$RE 7$G ]$Y Detector de artefactos visuales$G"
        echo -e "[$RE 0$G ]$Y Volver$RE"
        
        read -p " >> " diag_opt
        
        case $diag_opt in
            1) _CheckMediaIntegrity ;;
            2) _VideoQualityAnalysis ;;
            3) _GenerateAudioSpectrogram ;;
            4) _GenerateTechReport ;;
            5) _MediaComparison ;;
            6) _RunBenchmark ;;
            7) _VisualArtifactDetection ;;
            0) return ;;
            *) echo -e $R"Opción inválida$RE"; sleep 1 ;;
        esac
    done
}

function _CheckMediaIntegrity() {
    _Logo
    echo -e "$G VERIFICACIÓN DE INTEGRIDAD DE ARCHIVOS$RE"
    echo -e "$Y Selecciona archivo a verificar:$RE"
    read -p " >> " media_file
    
    if [ ! -f "$media_file" ]; then
        echo -e $R"Archivo no encontrado$RE"
        sleep 2
        return
    fi
    
    _Logo
    echo -e "$Y Analizando $media_file...$RE"
    
    # Verificar con FFprobe
    error_count=0
    integrity_report=""
    
    # Video
    if ffprobe -v error -i "$media_file" -show_streams -select_streams v:0 > /dev/null 2>&1; then
        integrity_report+="$G✓ Video stream: OK$RE\n"
    else
        integrity_report+="$R✗ Video stream: CORRUPTO$RE\n"
        error_count=$((error_count+1))
    fi
    
    # Audio
    if ffprobe -v error -i "$media_file" -show_streams -select_streams a:0 > /dev/null 2>&1; then
        integrity_report+="$G✓ Audio stream: OK$RE\n"
    else
        integrity_report+="$R✗ Audio stream: CORRUPTO$RE\n"
        error_count=$((error_count+1))
    fi
    
    # Metadatos
    if ffprobe -v error -i "$media_file" -show_format > /dev/null 2>&1; then
        integrity_report+="$G✓ Metadatos: OK$RE\n"
    else
        integrity_report+="$R✗ Metadatos: DAÑADOS$RE\n"
        error_count=$((error_count+1))
    fi
    
    # Resultado final
    _Logo
    echo -e "$G RESULTADO DE VERIFICACIÓN$RE"
    echo -e "Archivo: $media_file"
    echo -e "$integrity_report"
    
    if [ $error_count -eq 0 ]; then
        echo -e "$G El archivo está completamente íntegro$RE"
    else
        echo -e "$R Se encontraron $error_count problemas de integridad$RE"
    fi
    
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _VideoQualityAnalysis() {
    _Logo
    echo -e "$G ANÁLISIS DE CALIDAD DE VIDEO$RE"
    echo -e "$Y Selecciona archivo de video:$RE"
    read -p " >> " video_file
    
    if [ ! -f "$video_file" ]; then
        echo -e $R"Archivo no encontrado$RE"
        sleep 2
        return
    fi
    
    # Crear archivo temporal para análisis
    temp_dir="/data/data/com.termux/files/usr/tmp/quality_analysis"
    mkdir -p "$temp_dir"
    
    _Logo
    echo -e "$Y Realizando análisis de calidad...$RE"
    echo -e "$C Esto puede tomar varios minutos$RE"
    
    # Ejecutar análisis PSNR/SSIM
    ffmpeg -i "$video_file" -vf "split=2[a][b],[b]stats=reset=1:metadata=1[stats],[a][stats]ssim=stats_file=$temp_dir/ssim.log" -f null - 2> "$temp_dir/psnr.log"
    
    # Procesar resultados
    psnr_value=$(grep "PSNR" "$temp_dir/psnr.log" | awk '{print $7}' | sort -n | tail -1)
    ssim_value=$(tail -1 "$temp_dir/ssim.log" | awk -F: '{print $2}' | tr -d ' ')
    
    # Interpretar resultados
    if [ -z "$psnr_value" ]; then
        psnr_rating="$R No disponible$RE"
    elif (( $(echo "$psnr_value > 45" | bc -l) )); then
        psnr_rating="$G Excelente (>45 dB)$RE"
    elif (( $(echo "$psnr_value > 35" | bc -l) )); then
        psnr_rating="$B Bueno (35-45 dB)$RE"
    else
        psnr_rating="$R Pobre (<35 dB)$RE"
    fi
    
    if [ -z "$ssim_value" ]; then
        ssim_rating="$R No disponible$RE"
    elif (( $(echo "$ssim_value > 0.95" | bc -l) )); then
        ssim_rating="$G Excelente (>0.95)$RE"
    elif (( $(echo "$ssim_value > 0.85" | bc -l) )); then
        ssim_rating="$B Bueno (0.85-0.95)$RE"
    else
        ssim_rating="$R Pobre (<0.85)$RE"
    fi
    
    # Mostrar reporte
    _Logo
    echo -e "$G INFORME DE CALIDAD DE VIDEO$RE"
    echo -e "Archivo: $video_file"
    echo -e "--------------------------------"
    echo -e "$Y PSNR (Peak Signal-to-Noise Ratio):$RE"
    echo -e "Valor: $psnr_value dB"
    echo -e "Calidad: $psnr_rating"
    echo -e ""
    echo -e "$Y SSIM (Structural Similarity Index):$RE"
    echo -e "Valor: $ssim_value"
    echo -e "Calidad: $ssim_rating"
    echo -e ""
    echo -e "$C Nota: PSNR mide distorsión, SSIM mide similitud estructural$RE"
    
    # Limpiar temporales
    rm -rf "$temp_dir"
    
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _GenerateAudioSpectrogram() {
    _Logo
    echo -e "$G GENERADOR DE ESPECTROGRAMA$RE"
    echo -e "$Y Selecciona archivo de audio:$RE"
    read -p " >> " audio_file
    
    if [ ! -f "$audio_file" ]; then
        echo -e $R"Archivo no encontrado$RE"
        sleep 2
        return
    fi
    
    output_image="${audio_file%.*}_spectrogram.png"
    
    _Logo
    echo -e "$Y Generando espectrograma...$RE"
    
    # Crear espectrograma con FFmpeg
    ffmpeg -i "$audio_file" -lavfi showspectrumpic=s=1024x512:color=rainbow "$output_image" > /dev/null 2>&1
    
    if [ -f "$output_image" ]; then
        _Logo
        echo -e "$G ESPECTROGRAMA GENERADO$RE"
        echo -e "Archivo: $output_image"
        echo -e ""
        
        # Mostrar interpretación básica
        echo -e "$Y Interpretación básica:$RE"
        echo -e "- Frecuencias bajas (inferior): Graves"
        echo -e "- Frecuencias altas (superior): Agudos"
        echo -e "- Colores brillantes: Mayor energía"
        echo -e "- Patrones verticales: Eventos en el tiempo"
        echo -e "- Líneas horizontales: Tono constante"
        
        # Mostrar en el dispositivo si es posible
        if command -v termux-open > /dev/null; then
            echo -e "$Y ¿Abrir imagen? (s/n)$RE"
            read -p " >> " open_img
            if [[ "$open_img" =~ [sS] ]]; then
                termux-open "$output_image"
            fi
        fi
    else
        echo -e $R"Error al generar espectrograma$RE"
    fi
    
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _GenerateTechReport() {
    _Logo
    echo -e "$G GENERADOR DE INFORME TÉCNICO$RE"
    echo -e "$Y Selecciona archivo multimedia:$RE"
    read -p " >> " media_file
    
    if [ ! -f "$media_file" ]; then
        echo -e $R"Archivo no encontrado$RE"
        sleep 2
        return
    fi
    
    report_file="${media_file%.*}_tech_report.txt"
    
    _Logo
    echo -e "$Y Generando informe técnico...$RE"
    
    # Obtener información básica
    file_size=$(du -h "$media_file" | cut -f1)
    file_type=$(file -b --mime-type "$media_file")
    duration=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$media_file")
    duration_formatted=$(printf "%02d:%02d:%02d\n" $((duration/3600)) $((duration%3600/60)) $((duration%60)))
    
    # Iniciar reporte
    {
        echo "=============================================="
        echo "        INFORME TÉCNICO MULTIMEDIA"
        echo "=============================================="
        echo "Archivo: $(basename "$media_file")"
        echo "Ruta: $media_file"
        echo "Tamaño: $file_size"
        echo "Tipo: $file_type"
        echo "Duración: $duration_formatted"
        echo "Fecha de análisis: $(date)"
        echo "=============================================="
        echo ""
    } > "$report_file"
    
    # Información detallada de FFprobe
    {
        echo "-------------------------------"
        echo "METADATOS Y STREAMS"
        echo "-------------------------------"
        ffprobe -v error -show_format -show_streams "$media_file"
        echo ""
    } >> "$report_file"
    
    # Información de códecs
    {
        echo "-------------------------------"
        echo "INFORMACIÓN DE CÓDECS"
        echo "-------------------------------"
        ffprobe -v error -show_format -show_streams -print_format json "$media_file" | jq -r '["Tipo","Códec","Perfil","Bitrate","Resolución/Ajustes"], (.streams[] | [.codec_type, .codec_name, .profile, .bit_rate, (if .codec_type == "video" then "\(.width)x\(.height)" else .sample_rate + "Hz/" + .channel_layout end)]) | @tsv'
        echo ""
    } >> "$report_file"
    
    # Verificación de integridad
    {
        echo "-------------------------------"
        echo "VERIFICACIÓN DE INTEGRIDAD"
        echo "-------------------------------"
        if ffprobe -v error -i "$media_file" -show_streams > /dev/null; then
            echo "Estado: OK"
        else
            echo "Estado: CORRUPTO"
            echo "Errores detectados:"
            ffprobe -v error -i "$media_file" -show_streams 2>&1 | grep "error"
        fi
        echo ""
    } >> "$report_file"
    
    # Recomendaciones
    {
        echo "-------------------------------"
        echo "RECOMENDACIONES TÉCNICAS"
        echo "-------------------------------"
        video_codec=$(ffprobe -v error -select_streams v:0 -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 "$media_file")
        audio_codec=$(ffprobe -v error -select_streams a:0 -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 "$media_file")
        
        echo "1. Códec de video: $video_codec"
        if [[ "$video_codec" != "h264" ]] && [[ "$video_codec" != "h265" ]] && [[ "$video_codec" != "vp9" ]]; then
            echo "   Recomendación: Considerar convertir a H.265 para mejor compresión"
        fi
        
        echo "2. Códec de audio: $audio_codec"
        if [[ "$audio_codec" != "aac" ]] && [[ "$audio_codec" != "opus" ]]; then
            echo "   Recomendación: Considerar convertir a Opus para mejor calidad/compresión"
        fi
        
        echo ""
        echo "3. Optimización:"
        echo "   - Para web: H.264 + AAC en MP4"
        echo "   - Para almacenamiento: H.265 + Opus en MKV"
        echo "   - Máxima calidad: ProRes 422 o FLAC"
    } >> "$report_file"
    
    _Logo
    echo -e "$G INFORME GENERADO$RE"
    echo -e "Archivo: $report_file"
    echo -e ""
    echo -e "$Y ¿Deseas ver el informe ahora? (s/n)$RE"
    read -p " >> " view_report
    
    if [[ "$view_report" =~ [sS] ]]; then
        less "$report_file"
    fi
    
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _MediaComparison() {
    _Logo
    echo -e "$G COMPARACIÓN ENTRE ARCHIVOS$RE"
    echo -e "$Y Selecciona primer archivo:$RE"
    read -p " >> " file1
    echo -e "$Y Selecciona segundo archivo:$RE"
    read -p " >> " file2
    
    if [ ! -f "$file1" ] || [ ! -f "$file2" ]; then
        echo -e $R"Uno o ambos archivos no existen$RE"
        sleep 2
        return
    fi
    
    _Logo
    echo -e "$Y Realizando comparación...$RE"
    
    # Crear directorio temporal
    temp_dir="/data/data/com.termux/files/usr/tmp/comparison_$RANDOM"
    mkdir -p "$temp_dir"
    
    # Obtener información básica
    get_info() {
        echo "Tamaño: $(du -h "$1" | cut -f1)"
        echo "Duración: $(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$1" | awk '{printf "%02d:%02d:%02d", $1/3600, $1%3600/60, $1%60}')"
        echo "Video: $(ffprobe -v error -select_streams v:0 -show_entries stream=codec_name,width,height,bit_rate -of default=noprint_wrappers=1:nokey=1 "$1" | sed 's/\\n/ /g')"
        echo "Audio: $(ffprobe -v error -select_streams a:0 -show_entries stream=codec_name,sample_rate,channel_layout,bit_rate -of default=noprint_wrappers=1:nokey=1 "$1" | sed 's/\\n/ /g')"
    }
    
    # Generar comparación visual
    ffmpeg -i "$file1" -i "$file2" -filter_complex "[0:v]scale=640:360[0sc];[1:v]scale=640:360[1sc];[0sc][1sc]hstack=inputs=2" "$temp_dir/comparison.png" > /dev/null 2>&1
    
    # Generar informe
    _Logo
    echo -e "$G COMPARACIÓN: $(basename "$file1") vs $(basename "$file2")$RE"
    echo -e ""
    
    echo -e "$C========================================$RE"
    echo -e "$Y ARCHIVO 1: $file1$RE"
    echo -e "$C----------------------------------------$RE"
    get_info "$file1"
    echo -e ""
    
    echo -e "$C========================================$RE"
    echo -e "$Y ARCHIVO 2: $file2$RE"
    echo -e "$C----------------------------------------$RE"
    get_info "$file2"
    echo -e ""
    
    echo -e "$C========================================$RE"
    echo -e "$Y COMPARACIÓN VISUAL$RE"
    echo -e "$C Izquierda: $file1$RE"
    echo -e "$C Derecha: $file2$RE"
    echo -e ""
    
    # Mostrar imagen si es posible
    if [ -f "$temp_dir/comparison.png" ]; then
        if command -v termux-open > /dev/null; then
            termux-open "$temp_dir/comparison.png"
            echo -e "$G Imagen de comparación abierta$RE"
        else
            echo -e "$Y Imagen de comparación guardada en: $temp_dir/comparison.png$RE"
        fi
    fi
    
    # Limpiar
    rm -rf "$temp_dir"
    
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _RunBenchmark() {
    _Logo
    echo -e "$G BENCHMARK DE RENDIMIENTO$RE"
    echo -e "$Y Esta prueba evaluará la capacidad de procesamiento$RE"
    
    # Crear archivo de prueba
    test_file="/data/data/com.termux/files/usr/tmp/benchmark_test.mp4"
    if [ ! -f "$test_file" ]; then
        echo -e "$Y Generando archivo de prueba...$RE"
        ffmpeg -f lavfi -i testsrc=duration=10:size=hd1080:rate=30 -c:v libx264 -preset ultrafast "$test_file" > /dev/null 2>&1
    fi
    
    # Probar codificación
    _Logo
    echo -e "$Y Ejecutando pruebas...$RE"
    
    # H.264
    start_time=$(date +%s)
    ffmpeg -i "$test_file" -c:v libx264 -preset medium -f null - > /dev/null 2>&1
    h264_time=$(( $(date +%s) - start_time ))
    
    # H.265
    start_time=$(date +%s)
    ffmpeg -i "$test_file" -c:v libx265 -preset medium -f null - > /dev/null 2>&1
    h265_time=$(( $(date +%s) - start_time ))
    
    # VP9
    start_time=$(date +%s)
    ffmpeg -i "$test_file" -c:v vp9 -f null - > /dev/null 2>&1
    vp9_time=$(( $(date +%s) - start_time ))
    
    # Resultados
    _Logo
    echo -e "$G RESULTADOS DE BENCHMARK$RE"
    echo -e "$Y Tiempos de codificación (segundos):$RE"
    echo -e "H.264: $h264_time segundos"
    echo -e "H.265: $h265_time segundos"
    echo -e "VP9:   $vp9_time segundos"
    echo -e ""
    
    # Calcular puntuación
    score=$(( (h264_time + h265_time + vp9_time) / 3 ))
    echo -e "$Y Puntuación general: $score$RE"
    
    if [ $score -lt 10 ]; then
        echo -e "$G Excelente rendimiento!$RE"
    elif [ $score -lt 20 ]; then
        echo -e "$B Buen rendimiento$RE"
    else
        echo -e "$R Rendimiento limitado$RE"
    fi
    
    # Limpiar
    rm -f "$test_file"
    
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _VisualArtifactDetection() {
    _Logo
    echo -e "$G DETECCIÓN DE ARTEFACTOS VISUALES$RE"
    echo -e "$Y Selecciona archivo de video:$RE"
    read -p " >> " video_file
    
    if [ ! -f "$video_file" ]; then
        echo -e $R"Archivo no encontrado$RE"
        sleep 2
        return
    fi
    
    output_file="${video_file%.*}_artifact_report.txt"
    
    _Logo
    echo -e "$Y Analizando video...$RE"
    echo -e "$C Esto puede tomar varios minutos$RE"
    
    # Detectar artefactos de compresión
    ffmpeg -i "$video_file" -vf "idet,split=4[a][b][c][d],[a]copy[aa],[b]select=gt(scene\,0.3),scale=160:90,tile=10x10[bb],[c]select=eq(pict_type\,I),scale=160:90,tile=10x10[cc],[d]select=eq(pict_type\,B),scale=160:90,tile=10x10[dd],[aa][bb]overlay=0:0[out1],[out1][cc]overlay=0:0[out2],[out2][dd]overlay=0:0" -f null - 2> "$output_file"
    
    # Procesar resultados
    frame_data=$(grep "Parsed_idet" "$output_file")
    multi_frame=$(echo "$frame_data" | awk -F: '/Multi frame detection:/ {print $2}')
    tff=$(echo "$frame_data" | awk -F: '/TFF:/ {print $2}')
    bff=$(echo "$frame_data" | awk -F: '/BFF:/ {print $2}')
    progressive=$(echo "$frame_data" | awk -F: '/Progressive:/ {print $2}')
    undetermined=$(echo "$frame_data" | awk -F: '/Undetermined:/ {print $2}')
    
    # Mostrar reporte
    _Logo
    echo -e "$G INFORME DE ARTEFACTOS VISUALES$RE"
    echo -e "Archivo: $video_file"
    echo -e "--------------------------------"
    echo -e "$Y Detección de frames repetidos:$RE $multi_frame"
    echo -e "$Y Interlacing Top Field First:$RE $tff"
    echo -e "$Y Interlacing Bottom Field First:$RE $bff"
    echo -e "$Y Frames progresivos:$RE $progressive"
    echo -e "$Y Frames indeterminados:$RE $undetermined"
    echo -e ""
    
    # Recomendaciones
    echo -e "$Y RECOMENDACIONES:$RE"
    if [ "$multi_frame" != "0" ]; then
        echo -e "$R - Se detectaron frames repetidos: Posible problema de framerate$RE"
    fi
    if [ "$tff" != "0" ] || [ "$bff" != "0" ]; then
        echo -e "$R - Video interlaced detectado: Considerar desentrelazar$RE"
    fi
    
    # Limpiar
    rm -f "$output_file"
    
    read -n 1 -p "Presiona ENTER para continuar..."
}

function _ProConsole() {
    _Logo
    echo -e "$G CONSOLA PROFESIONAL$RE"
    echo -e "$Y Modo avanzado de línea de comandos$RE"
    echo -e "$C Escribe 'exit' para volver al menú$RE"
    echo -e ""
    
    # Configurar historial
    history_file=~/.milux/console_history
    [ -f "$history_file" ] || touch "$history_file"
    history -r "$history_file"
    
    # Variables especiales
    PROJECT_DIR=""
    CURRENT_MEDIA=""
    
    while true; do
        read -e -p "ConverterPro >> " cmd
        
        # Guardar en historial
        history -s "$cmd"
        history -w "$history_file"
        
        # Comandos internos
        case $cmd in
            exit)
                return
                ;;
            help)
                echo -e "$Y Comandos disponibles:$RE"
                echo -e "  proj <dir>   - Establecer directorio de proyecto"
                echo -e "  load <file>  - Cargar archivo multimedia"
                echo -e "  analyze      - Analizar archivo cargado"
                echo -e "  preset       - Mostrar presets de conversión"
                echo -e "  batch        - Procesar directorio completo"
                echo -e "  exit         - Salir de la consola"
                ;;
            proj*)
                dir=${cmd#proj }
                if [ -d "$dir" ]; then
                    PROJECT_DIR="$dir"
                    echo -e "$G Directorio de proyecto establecido: $dir$RE"
                else
                    echo -e $R"Directorio no válido$RE"
                fi
                ;;
            load*)
                file=${cmd#load }
                if [ -f "$file" ]; then
                    CURRENT_MEDIA="$file"
                    echo -e "$G Archivo cargado: $file$RE"
                else
                    echo -e $R"Archivo no encontrado$RE"
                fi
                ;;
            analyze)
                if [ -f "$CURRENT_MEDIA" ]; then
                    _AnalyzeMedia "$CURRENT_MEDIA"
                else
                    echo -e $R"No hay archivo cargado$RE"
                fi
                ;;
            preset)
                echo -e "$Y Presets disponibles:$G"
                echo -e "[$RE 1$G ]$Y YouTube 1080pA$G"
                echo -e "[$RE 2$G ]$Y Podcast HQ$G"
                echo -e "[$RE 3$G ]$Y Instagram Stories$G"
                echo -e "[$RE 4$G ]$Y Twitter Video$G"
                echo -e "[$RE 5$G ]$Y Archivo Master$RE"
                ;;
            batch)
                if [ -d "$PROJECT_DIR" ]; then
                    _BatchProcess "$PROJECT_DIR"
                else
                    echo -e $R"No se ha establecido directorio de proyecto$RE"
                fi
                ;;
            "")
                continue
                ;;
            *)
                # Ejecutar comando en el sistema
                eval "$cmd"
                ;;
        esac
    done
}

function _AnalyzeMedia() {
    local file=$1
    
    _Logo
    echo -e "$G ANÁLISIS PROFUNDO DE MEDIA$RE"
    echo -e "$Y Archivo: $file$RE"
    
    # Información básica
    echo -e "$C Tamaño: $(du -h "$file" | cut -f1)$RE"
    echo -e "$C Tipo: $(file -b --mime-type "$file")$RE"
    
    # Información detallada con FFprobe
    if [[ "$file" =~ \.(mp4|mov|avi|mkv|mp3|flac|wav)$ ]]; then
        echo -e "$Y Metadatos:$RE"
        ffprobe -v error -show_format -show_streams "$file" | grep -E 'codec_name|bit_rate|width|height|duration|TAG:'
    fi
    
    # Información de imagen con ImageMagick
    if [[ "$file" =~ \.(jpg|jpeg|png|gif|bmp)$ ]]; then
        echo -e "$Y Propiedades de imagen:$RE"
        identify -verbose "$file" | grep -E 'Geometry|Depth|Colorspace|Resolution|Filesize|Quality'
    fi
    
    read -n 1 -p "Presiona ENTER para continuar..."
}

# --------------------------------------------------
# SISTEMA DE NOTIFICACIONES Y SEGUIMIENTO
# --------------------------------------------------

NOTIF_LOG=~/.milux/notifications.log
mkdir -p ~/.milux

function _SendNotification() {
    local title=$1
    local message=$2
    local priority=${3:-normal}  # low, normal, high

    # Registrar en log
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] [$priority] $title: $message" >> "$NOTIF_LOG"

    # Mostrar en pantalla
    _Logo
    echo -e "$G$title$RE"
    echo -e "$Y$message$RE"
    echo ""

    # Enviar notificación al sistema si es posible
    if command -v termux-notification > /dev/null; then
        termux-notification \
            --title "$title" \
            --content "$message" \
            --priority "$priority" \
            --id "conv_$(date +%s)" \
            --button1 "Ver" --button1-action "termux-open '$NOTIF_LOG'" \
            > /dev/null
    fi
}

function _NotificationCenter() {
    _Logo
    echo -e "$G CENTRO DE NOTIFICACIONES$RE"
    echo -e "$Y Últimas notificaciones:$RE"

    # Mostrar últimas 10 notificaciones
    tail -n 10 "$NOTIF_LOG" | while read -r line; do
        echo -e "$C$line$RE"
    done

    echo -e "$G"
    echo -e "[$RE 1$G ]$Y Ver log completoi$G"
    echo -e "[$RE 2$G ]$Y Limpiar notificaciones$G"
    echo -e "[$RE 0$G ]$Y Volver"
    echo -e "$RE"

    read -p " >> " notif_opt

    case $notif_opt in
        1)
            less "$NOTIF_LOG"
            ;;
        2)
            > "$NOTIF_LOG"
            _SendNotification "Notificaciones" "Registro limpiado" "low"
            ;;
    	0)
		_Menu
    esac
}

# --------------------------------------------------
# CONVERSIÓN DESDE INTERNET
# --------------------------------------------------

function _InternetDownload() {
    _Logo
    echo -e "$G DESCARGAR Y CONVERTIR DESDE INTERNET$RE"
    echo -e "$Y Ingresa la URL del recurso:$RE"
    read -p " >> " media_url

    if [ -z "$media_url" ]; then
        _SendNotification "Descarga Internet" "URL inválida" "high"
        return
    fi

    # Directorio de descargas
    download_dir="/sdcard/Download/ConverterOnline"
    mkdir -p "$download_dir"

    # Obtener nombre de archivo
    filename=$(basename "$media_url")
    extension="${filename##*.}"
    filename="${filename%.*}"

    _SendNotification "Descarga Internet" "Iniciando descarga: $filename"

    # Descargar con wget o curl
    temp_file="$download_dir/${filename}_temp.$extension"

    if command -v wget >/dev/null; then
        wget -O "$temp_file" "$media_url"
    elif command -v curl >/dev/null; then
        curl -o "$temp_file" -L "$media_url"
    else
        _SendNotification "Descarga Internet" "Error: wget/curl no instalados" "high"
        echo -e $R"Instala wget o curl primero: pkg install wget$RE"
        sleep 3
        return
    fi

    if [ ! -f "$temp_file" ]; then
        _SendNotification "Descarga Internet" "Error en descarga" "high"
        return
    fi

    _SendNotification "Descarga Internet" "Descarga completada: $filename.$extension"

    # Seleccionar formato de conversión
    _Logo
    echo -e "$G ARCHIVO DESCARGADO:$RE $filename.$extension"
    echo -e "$Y Selecciona formato de conversión:$G"
    echo -e "[$RE 1$G ]$Y Video: MP4 (H.264)$G"
    echo -e "[$RE 2$G ]$Y Video: WebM (VP9)$G"
    echo -e "[$RE 3$G ]$Y Audio: MP3$G"
    echo -e "[$RE 4$G ]$Y Audio: Opus$G"
    echo -e "[$RE 5$G ]$Y Imagen: JPG$G"
    echo -e "[$RE 6$G ]$Y Imagen: PNG$G"
    echo -e "[$RE 7$G ]$Y Mantener formato original$G"
    echo -e "[$RE 0$G ]$Y Cancelar$RE"

    read -p " >> " convert_opt

    case $convert_opt in
        1) format="mp4";  type="video"; cmd="-c:v libx264 -preset medium" ;;
        2) format="webm"; type="video"; cmd="-c:v libvpx-vp9 -b:v 1M" ;;
        3) format="mp3";  type="audio"; cmd="-c:a libmp3lame -q:a 2" ;;
        4) format="opus"; type="audio"; cmd="-c:a libopus -b:a 64k" ;;
        5) format="jpg";  type="image"; cmd="" ;;
        6) format="png";  type="image"; cmd="" ;;
        7) format="$extension"; type="none"; cmd="" ;;
        *) return ;;
    esac

    output_file="$download_dir/$filename.$format"

    # Convertir si es necesario
    if [ "$type" != "none" ] && [ "$format" != "$extension" ]; then
        _SendNotification "Conversión" "Convirtiendo a $format"

        case $type in
            video|audio)
                ffmpeg -i "$temp_file" $cmd "$output_file"
                ;;
            image)
                mogrify -format "$format" -path "$download_dir" "$temp_file"
                mv "${temp_file%.*}.$format" "$output_file"
                ;;
        esac

        if [ -f "$output_file" ]; then
            rm -f "$temp_file"
            _SendNotification "Conversión" "Conversión completada: $filename.$format"
        else
            _SendNotification "Conversión" "Error en conversión" "high"
            output_file="$temp_file"  # Mantener archivo original
        fi
    else
        output_file="$temp_file"
    fi

    # Preguntar por subida a la nube
    _SendNotification "Descarga Completada" "Archivo guardado en: $output_file"
    echo -e "$G ¿Subir a la nube? (s/n)$RE"
    read -p " >> " upload_choice

    if [[ "$upload_choice" =~ [sS] ]]; then
        _CloudUpload "$output_file"
    fi
}

# --------------------------------------------------
# SUBIDA A LA NUBE
# --------------------------------------------------

CLOUD_CONFIG=~/.milux/cloud.cfg

function _CloudSetup() {
    _Logo
    echo -e "$G CONFIGURACIÓN DE SERVICIOS EN LA NUBE$RE"
    echo -e "$Y Selecciona el servicio:$G"
    echo -e "[$RE 1$G ]$Y Google Drive$G"
    echo -e "[$RE 2$G ]$Y Dropbox$G"
    echo -e "[$RE 3$G ]$Y FTP Personal$G"
    echo -e "[$RE 4$G ]$Y Nextcloud/Owncloud$G"
    echo -e "[$RE 0$G ]$Y Volver$RE"

    read -p " >> " service_opt

    case $service_opt in
        1) service="gdrive" ;;
        2) service="dropbox" ;;
        3) service="ftp" ;;
        4) service="nextcloud" ;;
        0) _Menu ;;
        *) echo -e $R"Opción inválida$RE"; sleep 1; return ;;
    esac

    _Logo
    echo -e "$G CONFIGURANDO ${service^^}$RE"

    case $service in
        gdrive)
            echo -e "$Y Para usar Google Drive necesitas rclone.$RE"
            echo -e "$C Instala con: pkg install rclone$RE"
            echo -e "$Y Ejecuta 'rclone config' para configurar Google Drive$RE"
            read -p "Ingresa el nombre del remoto rclone: " remote_name
            echo "gdrive_remote=$remote_name" > "$CLOUD_CONFIG"
	    _CloudSetup
            ;;
        dropbox)
            echo -e "$Y Ingresa tu token de acceso de Dropbox:$RE"
            echo -e "$C Puedes obtenerlo en: https://www.dropbox.com/developers/apps$RE"
            read -p "Token: " dropbox_token
            echo "dropbox_token=$dropbox_token" > "$CLOUD_CONFIG"
	    _CloudSetup
            ;;
        ftp)
            echo -e "$Y Configuración FTP:$RE"
            read -p "Servidor: " ftp_server
            read -p "Puerto: " ftp_port
            read -p "Usuario: " ftp_user
            read -p "Contraseña: " ftp_pass
            read -p "Directorio remoto: " ftp_path
            echo "ftp_server=$ftp_server" > "$CLOUD_CONFIG"
            echo "ftp_port=$ftp_port" >> "$CLOUD_CONFIG"
            echo "ftp_user=$ftp_user" >> "$CLOUD_CONFIG"
            echo "ftp_pass=$ftp_pass" >> "$CLOUD_CONFIG"
            echo "ftp_path=$ftp_path" >> "$CLOUD_CONFIG"
	    _CloudSetup
            ;;
        nextcloud)
            echo -e "$Y Configuración Nextcloud:$RE"
            read -p "URL del servidor: " nc_server
            read -p "Usuario: " nc_user
            read -p "Contraseña: " nc_pass
            read -p "Directorio remoto: " nc_path
            echo "nc_server=$nc_server" > "$CLOUD_CONFIG"
            echo "nc_user=$nc_user" >> "$CLOUD_CONFIG"
            echo "nc_pass=$nc_pass" >> "$CLOUD_CONFIG"
            echo "nc_path=$nc_path" >> "$CLOUD_CONFIG"
	    _CloudSetup
            ;;
    esac

    _SendNotification "Configuración Nube" "Servicio $service configurado"
}

function _CloudUpload() {
    local file_path=$1
    local filename=$(basename "$file_path")

    _Logo
    echo -e "$G SUBIR A LA NUBE$RE"
    echo -e "$Y Archivo: $filename$RE"

    if [ ! -f "$CLOUD_CONFIG" ]; then
        _SendNotification "Subida Nube" "Servicio no configurado" "high"
        echo -e $R"Primero configura un servicio en la nube$RE"
        sleep 2
        _CloudSetup
        return
    fi

    # Cargar configuración
    source "$CLOUD_CONFIG"

    echo -e "$Y Selecciona el servicio:$G"
    echo -e "[$RE 1$G ]$Y Google Drive$G"
    echo -e "[$RE 2$G ]$Y Dropbox$G"
    echo -e "[$RE 3$G ]$Y FTP$G"
    echo -e "[$RE 4$G ]$Y Nextcloud$G"
    echo -e "[$RE 0$G ]$Y Cancelar$RE"

    read -p " >> " service_opt

    case $service_opt in
        1) service="gdrive" ;;
        2) service="dropbox" ;;
        3) service="ftp" ;;
        4) service="nextcloud" ;;
        0) return ;;
        *) echo -e $R"Opción inválida$RE"; sleep 1; return ;;
    esac

    _SendNotification "Subida Nube" "Iniciando subida a ${service^^}"

    case $service in
        gdrive)
            if command -v rclone >/dev/null && [ -n "$gdrive_remote" ]; then
                rclone copy "$file_path" "$gdrive_remote:ConverterUploads"
                if [ $? -eq 0 ]; then
                    _SendNotification "Google Drive" "Subida exitosa: $filename"
                else
                    _SendNotification "Google Drive" "Error en subida" "high"
                fi
            else
                _SendNotification "Google Drive" "rclone no configurado" "high"
            fi
            ;;

        dropbox)
            if [ -n "$dropbox_token" ] && command -v curl >/dev/null; then
                curl -X POST https://content.dropboxapi.com/2/files/upload \
                    --header "Authorization: Bearer $dropbox_token" \
                    --header "Content-Type: application/octet-stream" \
                    --header "Dropbox-API-Arg: {\"path\": \"/$filename\",\"mode\": \"add\",\"autorename\": true,\"mute\": false}" \
                    --data-binary @"$file_path"

                if [ $? -eq 0 ]; then
                    _SendNotification "Dropbox" "Subida exitosa: $filename"
                else
                    _SendNotification "Dropbox" "Error en subida" "high"
                fi
            else
                _SendNotification "Dropbox" "Token no configurado" "high"
            fi
            ;;

        ftp)
            if [ -n "$ftp_server" ] && command -v curl >/dev/null; then
                remote_path="$ftp_path/$filename"
                curl -T "$file_path" "ftp://$ftp_server:$ftp_port/$remote_path" \
                    --user "$ftp_user:$ftp_pass"

                if [ $? -eq 0 ]; then
                    _SendNotification "FTP" "Subida exitosa: $filename"
                else
                    _SendNotification "FTP" "Error en subida" "high"
                fi
            else
                _SendNotification "FTP" "Configuración incompleta" "high"
            fi
            ;;

        nextcloud)
            if [ -n "$nc_server" ] && command -v curl >/dev/null; then
                # Obtener URL de subida WebDAV
                webdav_url="${nc_server%/}/remote.php/dav/files/$nc_user${nc_path}/$filename"

                curl -X PUT -u "$nc_user:$nc_pass" \
                    "$webdav_url" --data-binary @"$file_path"

                if [ $? -eq 0 ]; then
                    _SendNotification "Nextcloud" "Subida exitosa: $filename"
                else
                    _SendNotification "Nextcloud" "Error en subida" "high"
                fi
            else
                _SendNotification "Nextcloud" "Configuración incompleta" "high"
            fi
            ;;
    esac
}

function _About() {
    _Logo
    echo -e $G"
    CONVERTER PROFESSIONAL EDITION v2.1
    ---------------------------------------------
    • Función principal: Suite avanzada de conversión y procesamiento multimedia para Termux.

    • Funcionalidades clave:
        - Conversión estándar: Audio, Imagen, Video, Extracción de audio
        - Perfiles preconfigurados: WhatsApp, Spotify, Instagram
        - Gestión de almacenamiento: Analizador de espacio, limpieza inteligente, organización automática
        - Modo Avanzado:
            - Editor de parámetros FFmpeg/ImageMagick
            - Scripting avanzado y programación de tareas
            - Monitor de recursos en tiempo real
            - Gestión de proyectos multimedia
            - Herramientas de diagnóstico (calidad, espectrogramas, informe técnico)
            - Consola profesional integrada
        - Descarga desde Internet + Subida a la nube (Drive, Dropbox, FTP, Nextcloud)
        - Sistema de notificaciones y registro de actividades

    • Dependencias principales: ffmpeg, imagemagick, rclone, termux-api, jq, curl, zip

    • Autor: </[M]iLu{×}_> | DNP
    • Canal: https://t.me/Ivam3by_Cinderella
    • GitHub: https://github.com/miluxmil/milux

    • Última actualización: $(date +"%d-%b-%Y")
    $RE"
    read -n 1 -p "Presiona ENTER para continuar..."
    _Menu
}

function _About2(){
	clear
	echo -e $G"
	            C O N V E R T E R
		           by
		</[M]iLu{×}_> | DNP | 2024

   CONVERTER$RE Creado para DNP (Developer New Programmers)
              Desarrollado por$G </[M]iLu{×}_>$RE
        para el canal$G https://t.me/Ivam3by_Cinderella$RE
	        bot ayuda$G https://t.me/Ivam3_Bot$RE
	
      	  Este script esta creado para facilitar
        el cambio de formatos multimedia, utilizando
    FFMPEG e Imagemagick  para su correcto funcionamiento

		¡GRACIAS POR INSTALAR CONVERTER!
  $C             </[M]iLu{×}_>$G https://t.me/miluxmil$RE
    "
    read -n 1 -p "ENTER To Continue.."
    bash $0
}

function _Update() {
    _Logo
    mkdir -p ~/.milux
    
    # Versión por defecto si es primera instalación
    [ ! -f ~/.milux/cav.mlx ] && echo "5.9" > ~/.milux/cav.mlx
    
    echo -e $G"Buscando actualizaciones..."
    sleep 1
    
    # Descargar información de versión
    curl -s -o ~/.milux/ccv.mlx https://raw.githubusercontent.com/miluxmil/milux/master/CCV
    REMOTE_VERSION=$(cat ~/.milux/ccv.mlx)
    LOCAL_VERSION=$(cat ~/.milux/cav.mlx)
    
    if [ "$REMOTE_VERSION" == "$LOCAL_VERSION" ]; then
        _Logo
        echo -e $G"Tienes la última versión (v$LOCAL_VERSION)$RE"
        sleep 2
    else
        _Logo
        echo -e $G"¡Nueva versión disponible!$RE"
        echo -e $Y"Tu versión: v$LOCAL_VERSION$RE"
        echo -e $Y"Versión remota: v$REMOTE_VERSION$RE"
        echo -e $C"Actualizando..."
        sleep 2
        
        PW=$(pwd)
        cd ~/.milux/
        
        # 1. Descargar changelog
        curl -s -o changelog.txt https://raw.githubusercontent.com/miluxmil/milux/master/CHANGELOG
        
        # 2. Descargar nueva versión
        curl -s -o converter https://raw.githubusercontent.com/miluxmil/milux/master/converter
        chmod 777 converter
        mv converter $PREFIX/bin/
        
        # 3. Actualizar versión local
        mv ~/.milux/ccv.mlx ~/.milux/cav.mlx
        
        cd $PW
        
        # 4. Mostrar changelog
        _ShowChangelog "$LOCAL_VERSION" "$REMOTE_VERSION"
        
        # 5. Reiniciar aplicación
        _Logo
        echo -e $G"¡Actualización completada!$RE"
        echo -e $Y"Reiniciando CONVERTER v$REMOTE_VERSION$RE"
        sleep 3
        bash "$0"
        exit  # Importante para salir de la versión anterior
    fi
}

function _ShowChangelog() {
    local OLD_VERSION="$1"
    local NEW_VERSION="$2"
    
    _Logo
    echo -e $Y"============================================="
    echo -e "  C A M B I O S   V E R S I Ó N   $NEW_VERSION"
    echo -e "=============================================$RE"
    
    if [ -f ~/.milux/changelog.txt ]; then
        # Mostrar cambios desde la versión anterior hasta la nueva
        awk -v old_ver="Version $OLD_VERSION" -v new_ver="Version $NEW_VERSION" '
            $0 ~ new_ver { show=1; print; next }
            $0 ~ old_ver { show=0 }
            show && /^Version / { exit }
            show { print }
        ' ~/.milux/changelog.txt
    else
        echo -e $R"No se encontró el registro de cambios$RE"
    fi
    
    echo -e $Y"============================================="
    echo -e $G"Presiona ENTER para iniciar la nueva versión"
    read -n 1
}

function _Update1() {
    _Logo
    mkdir -p ~/.milux
    [ ! -f ~/.milux/cav.mlx ] && echo "V-2.0" > ~/.milux/cav.mlx
    
    echo -e $G"Espera mientras busco la última versión"
    sleep 2
    
    curl -s -o ~/.milux/ccv.mlx https://raw.githubusercontent.com/miluxmil/milux/master/CCV
    CAV=$(cat ~/.milux/ccv.mlx)
    CCV=$(cat ~/.milux/cav.mlx)
    
    if [ "$CAV" == "$CCV" ]; then
        _Logo
        echo -e $G"Tienes la última versión$RE"
        sleep 2
    else
        _Logo
        echo -e $G"Nueva versión encontrada!\nActualizando..."
        sleep 2
        PW=$(pwd)
        cd ~/.milux/
        curl -s -o converter https://raw.githubusercontent.com/miluxmil/milux/master/converter
        chmod 777 converter
        mv converter $PREFIX/bin/
        cd $PW
        mv ~/.milux/ccv.mlx ~/.milux/cav.mlx
        _Logo
        echo -e $G"Actualizado correctamente"
        sleep 2
    fi
    bash $0
}

trap "ctl_c" SIGINT

#clear
for (( i=0; i<msg_len; i++ )); do
	echo -n "${message:$i:1}"
	sleep 0.01
done
echo;sleep 2
_Menu
